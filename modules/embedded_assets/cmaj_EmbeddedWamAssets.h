//
//     ,ad888ba,                              88
//    d8"'    "8b
//   d8            88,dba,,adba,   ,aPP8A.A8  88     The Cmajor Toolkit
//   Y8,           88    88    88  88     88  88
//    Y8a.   .a8P  88    88    88  88,   ,88  88     (C)2024 Cmajor Software Ltd
//     '"Y888Y"'   88    88    88  '"8bbP"Y8  88     https://cmajor.dev
//                                           ,88
//                                        888P"
//
//  Cmajor may be used under the terms of the ISC license:
//
//  Permission to use, copy, modify, and/or distribute this software for any purpose with or
//  without fee is hereby granted, provided that the above copyright notice and this permission
//  notice appear in all copies. THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
//  WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
//  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
//  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
//  CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#pragma once

#include <array>
#include <string_view>

namespace cmaj
{

/// This contains the javascript support classes for web audio modules
///
struct EmbeddedWamAssets
{
    static std::string_view findResource (std::string_view path)
    {
        for (auto& file : files)
            if (path == file.name)
                return file.content;

        return {};
    }

    struct File { std::string_view name, content; };

    static constexpr const char* sdk_index_js = "// src/WebAudioModule.js\n"
        "var WebAudioModule = class {\n"
        "  static get isWebAudioModuleConstructor() {\n"
        "    return true;\n"
        "  }\n"
        "  static createInstance(groupId, audioContext, initialState) {\n"
        "    return new this(groupId, audioContext).initialize(initialState);\n"
        "  }\n"
        "  constructor(groupId, audioContext) {\n"
        "    this._groupId = groupId;\n"
        "    this._audioContext = audioContext;\n"
        "    this._initialized = false;\n"
        "    this._audioNode = void 0;\n"
        "    this._timestamp = performance.now();\n"
        "    this._guiModuleUrl = void 0;\n"
        "    this._descriptorUrl = \"./descriptor.json\";\n"
        "    this._descriptor = {\n"
        "      identifier: `com.webaudiomodule.default`,\n"
        "      name: `WebAudioModule_${this.constructor.name}`,\n"
        "      vendor: \"WebAudioModuleVendor\",\n"
        "      description: \"\",\n"
        "      version: \"0.0.0\",\n"
        "      apiVersion: \"2.0.0\",\n"
        "      thumbnail: \"\",\n"
        "      keywords: [],\n"
        "      isInstrument: false,\n"
        "      website: \"\",\n"
        "      hasAudioInput: true,\n"
        "      hasAudioOutput: true,\n"
        "      hasAutomationInput: true,\n"
        "      hasAutomationOutput: true,\n"
        "      hasMidiInput: true,\n"
        "      hasMidiOutput: true,\n"
        "      hasMpeInput: true,\n"
        "      hasMpeOutput: true,\n"
        "      hasOscInput: true,\n"
        "      hasOscOutput: true,\n"
        "      hasSysexInput: true,\n"
        "      hasSysexOutput: true\n"
        "    };\n"
        "  }\n"
        "  get isWebAudioModule() {\n"
        "    return true;\n"
        "  }\n"
        "  get groupId() {\n"
        "    return this._groupId;\n"
        "  }\n"
        "  get moduleId() {\n"
        "    return this.descriptor.identifier;\n"
        "  }\n"
        "  get instanceId() {\n"
        "    return this.moduleId + this._timestamp;\n"
        "  }\n"
        "  get descriptor() {\n"
        "    return this._descriptor;\n"
        "  }\n"
        "  get identifier() {\n"
        "    return this.descriptor.identifier;\n"
        "  }\n"
        "  get name() {\n"
        "    return this.descriptor.name;\n"
        "  }\n"
        "  get vendor() {\n"
        "    return this.descriptor.vendor;\n"
        "  }\n"
        "  get audioContext() {\n"
        "    return this._audioContext;\n"
        "  }\n"
        "  get audioNode() {\n"
        "    if (!this.initialized)\n"
        "      console.warn(\"WAM should be initialized before getting the audioNode\");\n"
        "    return this._audioNode;\n"
        "  }\n"
        "  set audioNode(node) {\n"
        "    this._audioNode = node;\n"
        "  }\n"
        "  get initialized() {\n"
        "    return this._initialized;\n"
        "  }\n"
        "  set initialized(value) {\n"
        "    this._initialized = value;\n"
        "  }\n"
        "  async createAudioNode(initialState) {\n"
        "    throw new TypeError(\"createAudioNode() not provided\");\n"
        "  }\n"
        "  async initialize(state) {\n"
        "    if (!this._audioNode)\n"
        "      this.audioNode = await this.createAudioNode();\n"
        "    this.initialized = true;\n"
        "    return this;\n"
        "  }\n"
        "  async _loadGui() {\n"
        "    const url = this._guiModuleUrl;\n"
        "    if (!url)\n"
        "      throw new TypeError(\"Gui module not found\");\n"
        "    return import(\n"
        "      /* webpackIgnore: true */\n"
        "      url\n"
        "    );\n"
        "  }\n"
        "  async _loadDescriptor() {\n"
        "    const url = this._descriptorUrl;\n"
        "    if (!url)\n"
        "      throw new TypeError(\"Descriptor not found\");\n"
        "    const response = await fetch(url);\n"
        "    const descriptor = await response.json();\n"
        "    Object.assign(this._descriptor, descriptor);\n"
        "    return this._descriptor;\n"
        "  }\n"
        "  async createGui() {\n"
        "    if (!this.initialized)\n"
        "      console.warn(\"Plugin should be initialized before getting the gui\");\n"
        "    if (!this._guiModuleUrl)\n"
        "      return void 0;\n"
        "    const { createElement } = await this._loadGui();\n"
        "    return createElement(this);\n"
        "  }\n"
        "  destroyGui() {\n"
        "  }\n"
        "};\n"
        "var WebAudioModule_default = WebAudioModule;\n"
        "\n"
        "// src/RingBuffer.js\n"
        "var getRingBuffer = (moduleId) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  class RingBuffer2 {\n"
        "    static getStorageForCapacity(capacity, Type) {\n"
        "      if (!Type.BYTES_PER_ELEMENT) {\n"
        "        throw new Error(\"Pass in a ArrayBuffer subclass\");\n"
        "      }\n"
        "      const bytes = 8 + (capacity + 1) * Type.BYTES_PER_ELEMENT;\n"
        "      return new SharedArrayBuffer(bytes);\n"
        "    }\n"
        "    constructor(sab, Type) {\n"
        "      if (!Type.BYTES_PER_ELEMENT) {\n"
        "        throw new Error(\"Pass a concrete typed array class as second argument\");\n"
        "      }\n"
        "      this._Type = Type;\n"
        "      this._capacity = (sab.byteLength - 8) / Type.BYTES_PER_ELEMENT;\n"
        "      this.buf = sab;\n"
        "      this.write_ptr = new Uint32Array(this.buf, 0, 1);\n"
        "      this.read_ptr = new Uint32Array(this.buf, 4, 1);\n"
        "      this.storage = new Type(this.buf, 8, this._capacity);\n"
        "    }\n"
        "    get type() {\n"
        "      return this._Type.name;\n"
        "    }\n"
        "    push(elements) {\n"
        "      const rd = Atomics.load(this.read_ptr, 0);\n"
        "      const wr = Atomics.load(this.write_ptr, 0);\n"
        "      if ((wr + 1) % this._storageCapacity() === rd) {\n"
        "        return 0;\n"
        "      }\n"
        "      const toWrite = Math.min(this._availableWrite(rd, wr), elements.length);\n"
        "      const firstPart = Math.min(this._storageCapacity() - wr, toWrite);\n"
        "      const secondPart = toWrite - firstPart;\n"
        "      this._copy(elements, 0, this.storage, wr, firstPart);\n"
        "      this._copy(elements, firstPart, this.storage, 0, secondPart);\n"
        "      Atomics.store(this.write_ptr, 0, (wr + toWrite) % this._storageCapacity());\n"
        "      return toWrite;\n"
        "    }\n"
        "    pop(elements) {\n"
        "      const rd = Atomics.load(this.read_ptr, 0);\n"
        "      const wr = Atomics.load(this.write_ptr, 0);\n"
        "      if (wr === rd) {\n"
        "        return 0;\n"
        "      }\n"
        "      const isArray = !Number.isInteger(elements);\n"
        "      const toRead = Math.min(this._availableRead(rd, wr), isArray ? elements.length : elements);\n"
        "      if (isArray) {\n"
        "        const firstPart = Math.min(this._storageCapacity() - rd, toRead);\n"
        "        const secondPart = toRead - firstPart;\n"
        "        this._copy(this.storage, rd, elements, 0, firstPart);\n"
        "        this._copy(this.storage, 0, elements, firstPart, secondPart);\n"
        "      }\n"
        "      Atomics.store(this.read_ptr, 0, (rd + toRead) % this._storageCapacity());\n"
        "      return toRead;\n"
        "    }\n"
        "    get empty() {\n"
        "      const rd = Atomics.load(this.read_ptr, 0);\n"
        "      const wr = Atomics.load(this.write_ptr, 0);\n"
        "      return wr === rd;\n"
        "    }\n"
        "    get full() {\n"
        "      const rd = Atomics.load(this.read_ptr, 0);\n"
        "      const wr = Atomics.load(this.write_ptr, 0);\n"
        "      return (wr + 1) % this._capacity !== rd;\n"
        "    }\n"
        "    get capacity() {\n"
        "      return this._capacity - 1;\n"
        "    }\n"
        "    get availableRead() {\n"
        "      const rd = Atomics.load(this.read_ptr, 0);\n"
        "      const wr = Atomics.load(this.write_ptr, 0);\n"
        "      return this._availableRead(rd, wr);\n"
        "    }\n"
        "    get availableWrite() {\n"
        "      const rd = Atomics.load(this.read_ptr, 0);\n"
        "      const wr = Atomics.load(this.write_ptr, 0);\n"
        "      return this._availableWrite(rd, wr);\n"
        "    }\n"
        "    _availableRead(rd, wr) {\n"
        "      if (wr > rd) {\n"
        "        return wr - rd;\n"
        "      }\n"
        "      return wr + this._storageCapacity() - rd;\n"
        "    }\n"
        "    _availableWrite(rd, wr) {\n"
        "      let rv = rd - wr - 1;\n"
        "      if (wr >= rd) {\n"
        "        rv += this._storageCapacity();\n"
        "      }\n"
        "      return rv;\n"
        "    }\n"
        "    _storageCapacity() {\n"
        "      return this._capacity;\n"
        "    }\n"
        "    _copy(input, offsetInput, output, offsetOutput, size) {\n"
        "      for (let i = 0; i < size; i++) {\n"
        "        output[offsetOutput + i] = input[offsetInput + i];\n"
        "      }\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "    if (!ModuleScope.RingBuffer)\n"
        "      ModuleScope.RingBuffer = RingBuffer2;\n"
        "  }\n"
        "  return RingBuffer2;\n"
        "};\n"
        "var RingBuffer_default = getRingBuffer;\n"
        "\n"
        "// src/WamArrayRingBuffer.js\n"
        "var getWamArrayRingBuffer = (moduleId) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  class WamArrayRingBuffer {\n"
        "    static DefaultArrayCapacity = 2;\n"
        "    static getStorageForEventCapacity(RingBuffer2, arrayLength, arrayType, maxArrayCapacity = void 0) {\n"
        "      if (maxArrayCapacity === void 0)\n"
        "        maxArrayCapacity = WamArrayRingBuffer.DefaultArrayCapacity;\n"
        "      else\n"
        "        maxArrayCapacity = Math.max(maxArrayCapacity, WamArrayRingBuffer.DefaultArrayCapacity);\n"
        "      if (!arrayType.BYTES_PER_ELEMENT) {\n"
        "        throw new Error(\"Pass in a ArrayBuffer subclass\");\n"
        "      }\n"
        "      const capacity = arrayLength * maxArrayCapacity;\n"
        "      return RingBuffer2.getStorageForCapacity(capacity, arrayType);\n"
        "    }\n"
        "    constructor(RingBuffer2, sab, arrayLength, arrayType, maxArrayCapacity = void 0) {\n"
        "      if (!arrayType.BYTES_PER_ELEMENT) {\n"
        "        throw new Error(\"Pass in a ArrayBuffer subclass\");\n"
        "      }\n"
        "      this._arrayLength = arrayLength;\n"
        "      this._arrayType = arrayType;\n"
        "      this._arrayElementSizeBytes = arrayType.BYTES_PER_ELEMENT;\n"
        "      this._arraySizeBytes = this._arrayLength * this._arrayElementSizeBytes;\n"
        "      this._sab = sab;\n"
        "      if (maxArrayCapacity === void 0)\n"
        "        maxArrayCapacity = WamArrayRingBuffer.DefaultArrayCapacity;\n"
        "      else\n"
        "        maxArrayCapacity = Math.max(maxArrayCapacity, WamArrayRingBuffer.DefaultArrayCapacity);\n"
        "      this._arrayArray = new arrayType(this._arrayLength);\n"
        "      this._rb = new RingBuffer2(this._sab, arrayType);\n"
        "    }\n"
        "    write(array) {\n"
        "      if (array.length !== this._arrayLength)\n"
        "        return false;\n"
        "      const elementsAvailable = this._rb.availableWrite;\n"
        "      if (elementsAvailable < this._arrayLength)\n"
        "        return false;\n"
        "      let success = true;\n"
        "      const elementsWritten = this._rb.push(array);\n"
        "      if (elementsWritten != this._arrayLength)\n"
        "        success = false;\n"
        "      return success;\n"
        "    }\n"
        "    read(array, newest) {\n"
        "      if (array.length !== this._arrayLength)\n"
        "        return false;\n"
        "      const elementsAvailable = this._rb.availableRead;\n"
        "      if (elementsAvailable < this._arrayLength)\n"
        "        return false;\n"
        "      if (newest && elementsAvailable > this._arrayLength)\n"
        "        this._rb.pop(elementsAvailable - this._arrayLength);\n"
        "      let success = false;\n"
        "      const elementsRead = this._rb.pop(array);\n"
        "      if (elementsRead === this._arrayLength)\n"
        "        success = true;\n"
        "      return success;\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "    if (!ModuleScope.WamArrayRingBuffer)\n"
        "      ModuleScope.WamArrayRingBuffer = WamArrayRingBuffer;\n"
        "  }\n"
        "  return WamArrayRingBuffer;\n"
        "};\n"
        "var WamArrayRingBuffer_default = getWamArrayRingBuffer;\n"
        "\n"
        "// src/WamEnv.js\n"
        "var initializeWamEnv = (apiVersion) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor && audioWorkletGlobalScope.webAudioModules)\n"
        "    return;\n"
        "  const moduleScopes = /* @__PURE__ */ new Map();\n"
        "  const groups = /* @__PURE__ */ new Map();\n"
        "  class WamEnv {\n"
        "    constructor() {\n"
        "    }\n"
        "    get apiVersion() {\n"
        "      return apiVersion;\n"
        "    }\n"
        "    getModuleScope(moduleId) {\n"
        "      if (!moduleScopes.has(moduleId))\n"
        "        moduleScopes.set(moduleId, {});\n"
        "      return moduleScopes.get(moduleId);\n"
        "    }\n"
        "    getGroup(groupId, groupKey) {\n"
        "      const group = groups.get(groupId);\n"
        "      if (group.validate(groupKey))\n"
        "        return group;\n"
        "      else\n"
        "        throw \"Invalid key\";\n"
        "    }\n"
        "    addGroup(group) {\n"
        "      if (!groups.has(group.groupId))\n"
        "        groups.set(group.groupId, group);\n"
        "    }\n"
        "    removeGroup(group) {\n"
        "      groups.delete(group.groupId);\n"
        "    }\n"
        "    addWam(wam) {\n"
        "      const group = groups.get(wam.groupId);\n"
        "      group.addWam(wam);\n"
        "    }\n"
        "    removeWam(wam) {\n"
        "      const group = groups.get(wam.groupId);\n"
        "      group.removeWam(wam);\n"
        "    }\n"
        "    connectEvents(groupId, fromId, toId, output = 0) {\n"
        "      const group = groups.get(groupId);\n"
        "      group.connectEvents(fromId, toId, output);\n"
        "    }\n"
        "    disconnectEvents(groupId, fromId, toId, output) {\n"
        "      const group = groups.get(groupId);\n"
        "      group.disconnectEvents(fromId, toId, output);\n"
        "    }\n"
        "    emitEvents(from, ...events) {\n"
        "      const group = groups.get(from.groupId);\n"
        "      group.emitEvents(from, ...events);\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    if (!audioWorkletGlobalScope.webAudioModules)\n"
        "      audioWorkletGlobalScope.webAudioModules = new WamEnv();\n"
        "  }\n"
        "};\n"
        "var WamEnv_default = initializeWamEnv;\n"
        "\n"
        "// src/WamGroup.js\n"
        "var initializeWamGroup = (groupId, groupKey) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  class WamGroup {\n"
        "    constructor(groupId2, groupKey2) {\n"
        "      this._groupId = groupId2;\n"
        "      this._validate = (key) => {\n"
        "        return key == groupKey2;\n"
        "      };\n"
        "      this._processors = /* @__PURE__ */ new Map();\n"
        "      this._eventGraph = /* @__PURE__ */ new Map();\n"
        "    }\n"
        "    get groupId() {\n"
        "      return this._groupId;\n"
        "    }\n"
        "    get processors() {\n"
        "      return this._processors;\n"
        "    }\n"
        "    get eventGraph() {\n"
        "      return this._eventGraph;\n"
        "    }\n"
        "    validate(groupKey2) {\n"
        "      return this._validate(groupKey2);\n"
        "    }\n"
        "    addWam(wam) {\n"
        "      this._processors.set(wam.instanceId, wam);\n"
        "    }\n"
        "    removeWam(wam) {\n"
        "      if (this._eventGraph.has(wam))\n"
        "        this._eventGraph.delete(wam);\n"
        "      this._eventGraph.forEach((outputMap) => {\n"
        "        outputMap.forEach((set) => {\n"
        "          if (set && set.has(wam))\n"
        "            set.delete(wam);\n"
        "        });\n"
        "      });\n"
        "      this._processors.delete(wam.instanceId);\n"
        "    }\n"
        "    connectEvents(fromId, toId, output) {\n"
        "      const from = this._processors.get(fromId);\n"
        "      const to = this._processors.get(toId);\n"
        "      let outputMap;\n"
        "      if (this._eventGraph.has(from)) {\n"
        "        outputMap = this._eventGraph.get(from);\n"
        "      } else {\n"
        "        outputMap = [];\n"
        "        this._eventGraph.set(from, outputMap);\n"
        "      }\n"
        "      if (outputMap[output]) {\n"
        "        outputMap[output].add(to);\n"
        "      } else {\n"
        "        const set = /* @__PURE__ */ new Set();\n"
        "        set.add(to);\n"
        "        outputMap[output] = set;\n"
        "      }\n"
        "    }\n"
        "    disconnectEvents(fromId, toId, output) {\n"
        "      const from = this._processors.get(fromId);\n"
        "      if (!this._eventGraph.has(from))\n"
        "        return;\n"
        "      const outputMap = this._eventGraph.get(from);\n"
        "      if (typeof toId === \"undefined\") {\n"
        "        outputMap.forEach((set) => {\n"
        "          if (set)\n"
        "            set.clear();\n"
        "        });\n"
        "        return;\n"
        "      }\n"
        "      const to = this._processors.get(toId);\n"
        "      if (typeof output === \"undefined\") {\n"
        "        outputMap.forEach((set) => {\n"
        "          if (set)\n"
        "            set.delete(to);\n"
        "        });\n"
        "        return;\n"
        "      }\n"
        "      if (!outputMap[output])\n"
        "        return;\n"
        "      outputMap[output].delete(to);\n"
        "    }\n"
        "    emitEvents(from, ...events) {\n"
        "      if (!this._eventGraph.has(from))\n"
        "        return;\n"
        "      const downstream = this._eventGraph.get(from);\n"
        "      downstream.forEach((set) => {\n"
        "        if (set)\n"
        "          set.forEach((wam) => wam.scheduleEvents(...events));\n"
        "      });\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    audioWorkletGlobalScope.webAudioModules.addGroup(new WamGroup(groupId, groupKey));\n"
        "  }\n"
        "};\n"
        "var WamGroup_default = initializeWamGroup;\n"
        "\n"
        "// src/WamEventRingBuffer.js\n"
        "var getWamEventRingBuffer = (moduleId) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  class WamEventRingBuffer2 {\n"
        "    static DefaultExtraBytesPerEvent = 64;\n"
        "    static WamEventBaseBytes = 4 + 1 + 8;\n"
        "    static WamAutomationEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 2 + 8 + 1;\n"
        "    static WamTransportEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 4 + 8 + 8 + 1 + 1 + 1;\n"
        "    static WamMidiEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 1 + 1 + 1;\n"
        "    static WamBinaryEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 4;\n"
        "    static getStorageForEventCapacity(RingBuffer2, eventCapacity, maxBytesPerEvent = void 0) {\n"
        "      if (maxBytesPerEvent === void 0)\n"
        "        maxBytesPerEvent = WamEventRingBuffer2.DefaultExtraBytesPerEvent;\n"
        "      else\n"
        "        maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer2.DefaultExtraBytesPerEvent);\n"
        "      const capacity = (Math.max(WamEventRingBuffer2.WamAutomationEventBytes, WamEventRingBuffer2.WamTransportEventBytes, WamEventRingBuffer2.WamMidiEventBytes, WamEventRingBuffer2.WamBinaryEventBytes) + maxBytesPerEvent) * eventCapacity;\n"
        "      return RingBuffer2.getStorageForCapacity(capacity, Uint8Array);\n"
        "    }\n"
        "    constructor(RingBuffer2, sab, parameterIds, maxBytesPerEvent = void 0) {\n"
        "      this._eventSizeBytes = {};\n"
        "      this._encodeEventType = {};\n"
        "      this._decodeEventType = {};\n"
        "      const wamEventTypes = [\"wam-automation\", \"wam-transport\", \"wam-midi\", \"wam-sysex\", \"wam-mpe\", \"wam-osc\", \"wam-info\"];\n"
        "      wamEventTypes.forEach((type, encodedType) => {\n"
        "        let byteSize = 0;\n"
        "        switch (type) {\n"
        "          case \"wam-automation\":\n"
        "            byteSize = WamEventRingBuffer2.WamAutomationEventBytes;\n"
        "            break;\n"
        "          case \"wam-transport\":\n"
        "            byteSize = WamEventRingBuffer2.WamTransportEventBytes;\n"
        "            break;\n"
        "          case \"wam-mpe\":\n"
        "          case \"wam-midi\":\n"
        "            byteSize = WamEventRingBuffer2.WamMidiEventBytes;\n"
        "            break;\n"
        "          case \"wam-osc\":\n"
        "          case \"wam-sysex\":\n"
        "          case \"wam-info\":\n"
        "            byteSize = WamEventRingBuffer2.WamBinaryEventBytes;\n"
        "            break;\n"
        "          default:\n"
        "            break;\n"
        "        }\n"
        "        this._eventSizeBytes[type] = byteSize;\n"
        "        this._encodeEventType[type] = encodedType;\n"
        "        this._decodeEventType[encodedType] = type;\n"
        "      });\n"
        "      this._parameterCode = 0;\n"
        "      this._parameterCodes = {};\n"
        "      this._encodeParameterId = {};\n"
        "      this._decodeParameterId = {};\n"
        "      this.setParameterIds(parameterIds);\n"
        "      this._sab = sab;\n"
        "      if (maxBytesPerEvent === void 0)\n"
        "        maxBytesPerEvent = WamEventRingBuffer2.DefaultExtraBytesPerEvent;\n"
        "      else\n"
        "        maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer2.DefaultExtraBytesPerEvent);\n"
        "      this._eventBytesAvailable = Math.max(WamEventRingBuffer2.WamAutomationEventBytes, WamEventRingBuffer2.WamTransportEventBytes, WamEventRingBuffer2.WamMidiEventBytes, WamEventRingBuffer2.WamBinaryEventBytes) + maxBytesPerEvent;\n"
        "      this._eventBytes = new ArrayBuffer(this._eventBytesAvailable);\n"
        "      this._eventBytesView = new DataView(this._eventBytes);\n"
        "      this._rb = new RingBuffer2(this._sab, Uint8Array);\n"
        "      this._eventSizeArray = new Uint8Array(this._eventBytes, 0, 4);\n"
        "      this._eventSizeView = new DataView(this._eventBytes, 0, 4);\n"
        "    }\n"
        "    _writeHeader(byteSize, type, time) {\n"
        "      let byteOffset = 0;\n"
        "      this._eventBytesView.setUint32(byteOffset, byteSize);\n"
        "      byteOffset += 4;\n"
        "      this._eventBytesView.setUint8(byteOffset, this._encodeEventType[type]);\n"
        "      byteOffset += 1;\n"
        "      this._eventBytesView.setFloat64(byteOffset, Number.isFinite(time) ? time : -1);\n"
        "      byteOffset += 8;\n"
        "      return byteOffset;\n"
        "    }\n"
        "    _encode(event) {\n"
        "      let byteOffset = 0;\n"
        "      const { type, time } = event;\n"
        "      switch (event.type) {\n"
        "        case \"wam-automation\":\n"
        "          {\n"
        "            if (!(event.data.id in this._encodeParameterId))\n"
        "              break;\n"
        "            const byteSize = this._eventSizeBytes[type];\n"
        "            byteOffset = this._writeHeader(byteSize, type, time);\n"
        "            const { data } = event;\n"
        "            const encodedParameterId = this._encodeParameterId[data.id];\n"
        "            const { value, normalized } = data;\n"
        "            this._eventBytesView.setUint16(byteOffset, encodedParameterId);\n"
        "            byteOffset += 2;\n"
        "            this._eventBytesView.setFloat64(byteOffset, value);\n"
        "            byteOffset += 8;\n"
        "            this._eventBytesView.setUint8(byteOffset, normalized ? 1 : 0);\n"
        "            byteOffset += 1;\n"
        "          }\n"
        "          break;\n"
        "        case \"wam-transport\":\n"
        "          {\n"
        "            const byteSize = this._eventSizeBytes[type];\n"
        "            byteOffset = this._writeHeader(byteSize, type, time);\n"
        "            const { data } = event;\n"
        "            const {\n"
        "              currentBar,\n"
        "              currentBarStarted,\n"
        "              tempo,\n"
        "              timeSigNumerator,\n"
        "              timeSigDenominator,\n"
        "              playing\n"
        "            } = data;\n"
        "            this._eventBytesView.setUint32(byteOffset, currentBar);\n"
        "            byteOffset += 4;\n"
        "            this._eventBytesView.setFloat64(byteOffset, currentBarStarted);\n"
        "            byteOffset += 8;\n"
        "            this._eventBytesView.setFloat64(byteOffset, tempo);\n"
        "            byteOffset += 8;\n"
        "            this._eventBytesView.setUint8(byteOffset, timeSigNumerator);\n"
        "            byteOffset += 1;\n"
        "            this._eventBytesView.setUint8(byteOffset, timeSigDenominator);\n"
        "            byteOffset += 1;\n"
        "            this._eventBytesView.setUint8(byteOffset, playing ? 1 : 0);\n"
        "            byteOffset += 1;\n"
        "          }\n"
        "          break;\n"
        "        case \"wam-mpe\":\n"
        "        case \"wam-midi\":\n"
        "          {\n"
        "            const byteSize = this._eventSizeBytes[type];\n"
        "            byteOffset = this._writeHeader(byteSize, type, time);\n"
        "            const { data } = event;\n"
        "            const { bytes } = data;\n"
        "            let b = 0;\n"
        "            while (b < 3) {\n"
        "              this._eventBytesView.setUint8(byteOffset, bytes[b]);\n"
        "              byteOffset += 1;\n"
        "              b++;\n"
        "            }\n"
        "          }\n"
        "          break;\n"
        "        case \"wam-osc\":\n"
        "        case \"wam-sysex\":\n"
        "        case \"wam-info\":\n"
        "          {\n"
        "            let bytes = null;\n"
        "            if (event.type === \"wam-info\") {\n"
        "              const { data } = event;\n"
        "              bytes = new TextEncoder().encode(data.instanceId);\n"
        "            } else {\n"
        "              const { data } = event;\n"
        "              bytes = data.bytes;\n"
        "            }\n"
        "            const numBytes = bytes.length;\n"
        "            const byteSize = this._eventSizeBytes[type];\n"
        "            byteOffset = this._writeHeader(byteSize + numBytes, type, time);\n"
        "            this._eventBytesView.setUint32(byteOffset, numBytes);\n"
        "            byteOffset += 4;\n"
        "            const bytesRequired = byteOffset + numBytes;\n"
        "            if (bytesRequired > this._eventBytesAvailable)\n"
        "              console.error(`Event requires ${bytesRequired} bytes but only ${this._eventBytesAvailable} have been allocated!`);\n"
        "            const buffer = new Uint8Array(this._eventBytes, byteOffset, numBytes);\n"
        "            buffer.set(bytes);\n"
        "            byteOffset += numBytes;\n"
        "          }\n"
        "          break;\n"
        "        default:\n"
        "          break;\n"
        "      }\n"
        "      return new Uint8Array(this._eventBytes, 0, byteOffset);\n"
        "    }\n"
        "    _decode() {\n"
        "      let byteOffset = 0;\n"
        "      const type = this._decodeEventType[this._eventBytesView.getUint8(byteOffset)];\n"
        "      byteOffset += 1;\n"
        "      let time = this._eventBytesView.getFloat64(byteOffset);\n"
        "      if (time === -1)\n"
        "        time = void 0;\n"
        "      byteOffset += 8;\n"
        "      switch (type) {\n"
        "        case \"wam-automation\": {\n"
        "          const encodedParameterId = this._eventBytesView.getUint16(byteOffset);\n"
        "          byteOffset += 2;\n"
        "          const value = this._eventBytesView.getFloat64(byteOffset);\n"
        "          byteOffset += 8;\n"
        "          const normalized = !!this._eventBytesView.getUint8(byteOffset);\n"
        "          byteOffset += 1;\n"
        "          if (!(encodedParameterId in this._decodeParameterId))\n"
        "            break;\n"
        "          const id = this._decodeParameterId[encodedParameterId];\n"
        "          const event = {\n"
        "            type,\n"
        "            time,\n"
        "            data: {\n"
        "              id,\n"
        "              value,\n"
        "              normalized\n"
        "            }\n"
        "          };\n"
        "          return event;\n"
        "        }\n"
        "        case \"wam-transport\": {\n"
        "          const currentBar = this._eventBytesView.getUint32(byteOffset);\n"
        "          byteOffset += 4;\n"
        "          const currentBarStarted = this._eventBytesView.getFloat64(byteOffset);\n"
        "          byteOffset += 8;\n"
        "          const tempo = this._eventBytesView.getFloat64(byteOffset);\n"
        "          byteOffset += 8;\n"
        "          const timeSigNumerator = this._eventBytesView.getUint8(byteOffset);\n"
        "          byteOffset += 1;\n"
        "          const timeSigDenominator = this._eventBytesView.getUint8(byteOffset);\n"
        "          byteOffset += 1;\n"
        "          const playing = this._eventBytesView.getUint8(byteOffset) == 1;\n"
        "          byteOffset += 1;\n"
        "          const event = {\n"
        "            type,\n"
        "            time,\n"
        "            data: {\n"
        "              currentBar,\n"
        "              currentBarStarted,\n"
        "              tempo,\n"
        "              timeSigNumerator,\n"
        "              timeSigDenominator,\n"
        "              playing\n"
        "            }\n"
        "          };\n"
        "          return event;\n"
        "        }\n"
        "        case \"wam-mpe\":\n"
        "        case \"wam-midi\": {\n"
        "          const bytes = [0, 0, 0];\n"
        "          let b = 0;\n"
        "          while (b < 3) {\n"
        "            bytes[b] = this._eventBytesView.getUint8(byteOffset);\n"
        "            byteOffset += 1;\n"
        "            b++;\n"
        "          }\n"
        "          const event = {\n"
        "            type,\n"
        "            time,\n"
        "            data: { bytes }\n"
        "          };\n"
        "          return event;\n"
        "        }\n"
        "        case \"wam-osc\":\n"
        "        case \"wam-sysex\":\n"
        "        case \"wam-info\": {\n"
        "          const numBytes = this._eventBytesView.getUint32(byteOffset);\n"
        "          byteOffset += 4;\n"
        "          const bytes = new Uint8Array(numBytes);\n"
        "          bytes.set(new Uint8Array(this._eventBytes, byteOffset, numBytes));\n"
        "          byteOffset += numBytes;\n"
        "          if (type === \"wam-info\") {\n"
        "            const instanceId = new TextDecoder().decode(bytes);\n"
        "            const data = { instanceId };\n"
        "            return { type, time, data };\n"
        "          } else {\n"
        "            const data = { bytes };\n"
        "            return { type, time, data };\n"
        "          }\n"
        "        }\n"
        "        default:\n"
        "          break;\n"
        "      }\n"
        "      return false;\n"
        "    }\n"
        "    write(...events) {\n"
        "      const numEvents = events.length;\n"
        "      let bytesAvailable = this._rb.availableWrite;\n"
        "      let numSkipped = 0;\n"
        "      let i = 0;\n"
        "      while (i < numEvents) {\n"
        "        const event = events[i];\n"
        "        const bytes = this._encode(event);\n"
        "        const eventSizeBytes = bytes.byteLength;\n"
        "        let bytesWritten = 0;\n"
        "        if (bytesAvailable >= eventSizeBytes) {\n"
        "          if (eventSizeBytes === 0)\n"
        "            numSkipped++;\n"
        "          else\n"
        "            bytesWritten = this._rb.push(bytes);\n"
        "        } else\n"
        "          break;\n"
        "        bytesAvailable -= bytesWritten;\n"
        "        i++;\n"
        "      }\n"
        "      return i - numSkipped;\n"
        "    }\n"
        "    read() {\n"
        "      if (this._rb.empty)\n"
        "        return [];\n"
        "      const events = [];\n"
        "      let bytesAvailable = this._rb.availableRead;\n"
        "      let bytesRead = 0;\n"
        "      while (bytesAvailable > 0) {\n"
        "        bytesRead = this._rb.pop(this._eventSizeArray);\n"
        "        bytesAvailable -= bytesRead;\n"
        "        const eventSizeBytes = this._eventSizeView.getUint32(0);\n"
        "        const eventBytes = new Uint8Array(this._eventBytes, 0, eventSizeBytes - 4);\n"
        "        bytesRead = this._rb.pop(eventBytes);\n"
        "        bytesAvailable -= bytesRead;\n"
        "        const decodedEvent = this._decode();\n"
        "        if (decodedEvent)\n"
        "          events.push(decodedEvent);\n"
        "      }\n"
        "      return events;\n"
        "    }\n"
        "    setParameterIds(parameterIds) {\n"
        "      this._encodeParameterId = {};\n"
        "      this._decodeParameterId = {};\n"
        "      parameterIds.forEach((parameterId) => {\n"
        "        let parameterCode = -1;\n"
        "        if (parameterId in this._parameterCodes)\n"
        "          parameterCode = this._parameterCodes[parameterId];\n"
        "        else {\n"
        "          parameterCode = this._generateParameterCode();\n"
        "          this._parameterCodes[parameterId] = parameterCode;\n"
        "        }\n"
        "        this._encodeParameterId[parameterId] = parameterCode;\n"
        "        this._decodeParameterId[parameterCode] = parameterId;\n"
        "      });\n"
        "    }\n"
        "    _generateParameterCode() {\n"
        "      if (this._parameterCode > 65535)\n"
        "        throw Error(\"Too many parameters have been registered!\");\n"
        "      return this._parameterCode++;\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "    if (!ModuleScope.WamEventRingBuffer)\n"
        "      ModuleScope.WamEventRingBuffer = WamEventRingBuffer2;\n"
        "  }\n"
        "  return WamEventRingBuffer2;\n"
        "};\n"
        "var WamEventRingBuffer_default = getWamEventRingBuffer;\n"
        "\n"
        "// src/addFunctionModule.js\n"
        "var addFunctionModule = (audioWorklet, processorFunction, ...injection) => {\n"
        "  const text = `(${processorFunction.toString()})(${injection.map((s) => JSON.stringify(s)).join(\", \")});`;\n"
        "  const url = URL.createObjectURL(new Blob([text], { type: \"text/javascript\" }));\n"
        "  return audioWorklet.addModule(url);\n"
        "};\n"
        "var addFunctionModule_default = addFunctionModule;\n"
        "\n"
        "// src/WamParameter.js\n"
        "var getWamParameter = (moduleId) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  class WamParameter {\n"
        "    constructor(info) {\n"
        "      this.info = info;\n"
        "      this._value = info.defaultValue;\n"
        "    }\n"
        "    set value(value) {\n"
        "      this._value = value;\n"
        "    }\n"
        "    get value() {\n"
        "      return this._value;\n"
        "    }\n"
        "    set normalizedValue(valueNorm) {\n"
        "      this.value = this.info.denormalize(valueNorm);\n"
        "    }\n"
        "    get normalizedValue() {\n"
        "      return this.info.normalize(this.value);\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "    if (!ModuleScope.WamParameter)\n"
        "      ModuleScope.WamParameter = WamParameter;\n"
        "  }\n"
        "  return WamParameter;\n"
        "};\n"
        "var WamParameter_default = getWamParameter;\n"
        "\n"
        "// src/WamParameterInfo.js\n"
        "var getWamParameterInfo = (moduleId) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  const normExp = (x, e) => e === 0 ? x : x ** 1.5 ** -e;\n"
        "  const denormExp = (x, e) => e === 0 ? x : x ** 1.5 ** e;\n"
        "  const normalize = (x, min, max, e = 0) => min === 0 && max === 1 ? normExp(x, e) : normExp((x - min) / (max - min) || 0, e);\n"
        "  const denormalize = (x, min, max, e = 0) => min === 0 && max === 1 ? denormExp(x, e) : denormExp(x, e) * (max - min) + min;\n"
        "  const inRange = (x, min, max) => x >= min && x <= max;\n"
        "  class WamParameterInfo {\n"
        "    constructor(id, config = {}) {\n"
        "      let {\n"
        "        type,\n"
        "        label,\n"
        "        defaultValue,\n"
        "        minValue,\n"
        "        maxValue,\n"
        "        discreteStep,\n"
        "        exponent,\n"
        "        choices,\n"
        "        units\n"
        "      } = config;\n"
        "      if (type === void 0)\n"
        "        type = \"float\";\n"
        "      if (label === void 0)\n"
        "        label = \"\";\n"
        "      if (defaultValue === void 0)\n"
        "        defaultValue = 0;\n"
        "      if (choices === void 0)\n"
        "        choices = [];\n"
        "      if (type === \"boolean\" || type === \"choice\") {\n"
        "        discreteStep = 1;\n"
        "        minValue = 0;\n"
        "        if (choices.length)\n"
        "          maxValue = choices.length - 1;\n"
        "        else\n"
        "          maxValue = 1;\n"
        "      } else {\n"
        "        if (minValue === void 0)\n"
        "          minValue = 0;\n"
        "        if (maxValue === void 0)\n"
        "          maxValue = 1;\n"
        "        if (discreteStep === void 0)\n"
        "          discreteStep = 0;\n"
        "        if (exponent === void 0)\n"
        "          exponent = 0;\n"
        "        if (units === void 0)\n"
        "          units = \"\";\n"
        "      }\n"
        "      const errBase = `Param config error | ${id}: `;\n"
        "      if (minValue >= maxValue)\n"
        "        throw Error(errBase.concat(\"minValue must be less than maxValue\"));\n"
        "      if (!inRange(defaultValue, minValue, maxValue))\n"
        "        throw Error(errBase.concat(\"defaultValue out of range\"));\n"
        "      if (discreteStep % 1 || discreteStep < 0) {\n"
        "        throw Error(errBase.concat(\"discreteStep must be a non-negative integer\"));\n"
        "      } else if (discreteStep > 0 && (minValue % 1 || maxValue % 1 || defaultValue % 1)) {\n"
        "        throw Error(errBase.concat(\"non-zero discreteStep requires integer minValue, maxValue, and defaultValue\"));\n"
        "      }\n"
        "      if (type === \"choice\" && !choices.length) {\n"
        "        throw Error(errBase.concat(\"choice type parameter requires list of strings in choices\"));\n"
        "      }\n"
        "      this.id = id;\n"
        "      this.label = label;\n"
        "      this.type = type;\n"
        "      this.defaultValue = defaultValue;\n"
        "      this.minValue = minValue;\n"
        "      this.maxValue = maxValue;\n"
        "      this.discreteStep = discreteStep;\n"
        "      this.exponent = exponent;\n"
        "      this.choices = choices;\n"
        "      this.units = units;\n"
        "    }\n"
        "    normalize(value) {\n"
        "      return normalize(value, this.minValue, this.maxValue, this.exponent);\n"
        "    }\n"
        "    denormalize(valueNorm) {\n"
        "      return denormalize(valueNorm, this.minValue, this.maxValue, this.exponent);\n"
        "    }\n"
        "    valueString(value) {\n"
        "      if (this.choices)\n"
        "        return this.choices[value];\n"
        "      if (this.units !== \"\")\n"
        "        return `${value} ${this.units}`;\n"
        "      return `${value}`;\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "    if (!ModuleScope.WamParameterInfo)\n"
        "      ModuleScope.WamParameterInfo = WamParameterInfo;\n"
        "  }\n"
        "  return WamParameterInfo;\n"
        "};\n"
        "var WamParameterInfo_default = getWamParameterInfo;\n"
        "\n"
        "// src/WamParameterInterpolator.js\n"
        "var getWamParameterInterpolator = (moduleId) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  const samplesPerQuantum = 128;\n"
        "  const nullTableKey = \"0_0\";\n"
        "  class WamParameterInterpolator {\n"
        "    static _tables;\n"
        "    static _tableReferences;\n"
        "    constructor(info, samplesPerInterpolation, skew = 0) {\n"
        "      if (!WamParameterInterpolator._tables) {\n"
        "        WamParameterInterpolator._tables = { nullTableKey: new Float32Array(0) };\n"
        "        WamParameterInterpolator._tableReferences = { nullTableKey: [] };\n"
        "      }\n"
        "      this.info = info;\n"
        "      this.values = new Float32Array(samplesPerQuantum);\n"
        "      this._tableKey = nullTableKey;\n"
        "      this._table = WamParameterInterpolator._tables[this._tableKey];\n"
        "      this._skew = 2;\n"
        "      const { discreteStep } = info;\n"
        "      this._discrete = !!discreteStep;\n"
        "      this._N = this._discrete ? 0 : samplesPerInterpolation;\n"
        "      this._n = 0;\n"
        "      this._startValue = info.defaultValue;\n"
        "      this._endValue = info.defaultValue;\n"
        "      this._currentValue = info.defaultValue;\n"
        "      this._deltaValue = 0;\n"
        "      this._inverted = false;\n"
        "      this._changed = true;\n"
        "      this._filled = 0;\n"
        "      if (!this._discrete)\n"
        "        this.setSkew(skew);\n"
        "      else\n"
        "        this._skew = 0;\n"
        "      this.setStartValue(this._startValue);\n"
        "    }\n"
        "    _removeTableReference(oldKey) {\n"
        "      if (oldKey === nullTableKey)\n"
        "        return;\n"
        "      const { id } = this.info;\n"
        "      const references = WamParameterInterpolator._tableReferences[oldKey];\n"
        "      if (references) {\n"
        "        const index = references.indexOf(id);\n"
        "        if (index !== -1)\n"
        "          references.splice(index, 1);\n"
        "        if (references.length === 0) {\n"
        "          delete WamParameterInterpolator._tables[oldKey];\n"
        "          delete WamParameterInterpolator._tableReferences[oldKey];\n"
        "        }\n"
        "      }\n"
        "    }\n"
        "    setSkew(skew) {\n"
        "      if (this._skew === skew || this._discrete)\n"
        "        return;\n"
        "      if (skew < -1 || skew > 1)\n"
        "        throw Error(\"skew must be in range [-1.0, 1.0]\");\n"
        "      const newKey = [this._N, skew].join(\"_\");\n"
        "      const oldKey = this._tableKey;\n"
        "      const { id } = this.info;\n"
        "      if (newKey === oldKey)\n"
        "        return;\n"
        "      if (WamParameterInterpolator._tables[newKey]) {\n"
        "        const references = WamParameterInterpolator._tableReferences[newKey];\n"
        "        if (references)\n"
        "          references.push(id);\n"
        "        else\n"
        "          WamParameterInterpolator._tableReferences[newKey] = [id];\n"
        "      } else {\n"
        "        let e = Math.abs(skew);\n"
        "        e = Math.pow(3 - e, e * (e + 2));\n"
        "        const linear = e === 1;\n"
        "        const N = this._N;\n"
        "        const table = new Float32Array(N + 1);\n"
        "        if (linear)\n"
        "          for (let n = 0; n <= N; ++n)\n"
        "            table[n] = n / N;\n"
        "        else\n"
        "          for (let n = 0; n <= N; ++n)\n"
        "            table[n] = (n / N) ** e;\n"
        "        WamParameterInterpolator._tables[newKey] = table;\n"
        "        WamParameterInterpolator._tableReferences[newKey] = [id];\n"
        "      }\n"
        "      this._removeTableReference(oldKey);\n"
        "      this._skew = skew;\n"
        "      this._tableKey = newKey;\n"
        "      this._table = WamParameterInterpolator._tables[this._tableKey];\n"
        "    }\n"
        "    setStartValue(value, fill = true) {\n"
        "      this._n = this._N;\n"
        "      this._startValue = value;\n"
        "      this._endValue = value;\n"
        "      this._currentValue = value;\n"
        "      this._deltaValue = 0;\n"
        "      this._inverted = false;\n"
        "      if (fill) {\n"
        "        this.values.fill(value);\n"
        "        this._changed = true;\n"
        "        this._filled = this.values.length;\n"
        "      } else {\n"
        "        this._changed = false;\n"
        "        this._filled = 0;\n"
        "      }\n"
        "    }\n"
        "    setEndValue(value) {\n"
        "      if (value === this._endValue)\n"
        "        return;\n"
        "      this._n = 0;\n"
        "      this._startValue = this._currentValue;\n"
        "      this._endValue = value;\n"
        "      this._deltaValue = this._endValue - this._startValue;\n"
        "      this._inverted = this._deltaValue > 0 && this._skew >= 0 || this._deltaValue <= 0 && this._skew < 0;\n"
        "      this._changed = false;\n"
        "      this._filled = 0;\n"
        "    }\n"
        "    process(startSample, endSample) {\n"
        "      if (this.done)\n"
        "        return;\n"
        "      const length = endSample - startSample;\n"
        "      let fill = 0;\n"
        "      const change = this._N - this._n;\n"
        "      if (this._discrete || !change)\n"
        "        fill = length;\n"
        "      else {\n"
        "        if (change < length) {\n"
        "          fill = Math.min(length - change, samplesPerQuantum);\n"
        "          endSample -= fill;\n"
        "        }\n"
        "        if (endSample > startSample) {\n"
        "          if (this._inverted) {\n"
        "            for (let i = startSample; i < endSample; ++i) {\n"
        "              const tableValue = 1 - this._table[this._N - ++this._n];\n"
        "              this.values[i] = this._startValue + tableValue * this._deltaValue;\n"
        "            }\n"
        "          } else {\n"
        "            for (let i = startSample; i < endSample; ++i) {\n"
        "              const tableValue = this._table[++this._n];\n"
        "              this.values[i] = this._startValue + tableValue * this._deltaValue;\n"
        "            }\n"
        "          }\n"
        "        }\n"
        "        if (fill > 0) {\n"
        "          startSample = endSample;\n"
        "          endSample += fill;\n"
        "        }\n"
        "      }\n"
        "      if (fill > 0) {\n"
        "        this.values.fill(this._endValue, startSample, endSample);\n"
        "        this._filled += fill;\n"
        "      }\n"
        "      this._currentValue = this.values[endSample - 1];\n"
        "      if (this._n === this._N) {\n"
        "        if (!this._changed)\n"
        "          this._changed = true;\n"
        "        else if (this._filled >= this.values.length) {\n"
        "          this.setStartValue(this._endValue, false);\n"
        "          this._changed = true;\n"
        "          this._filled = this.values.length;\n"
        "        }\n"
        "      }\n"
        "    }\n"
        "    get done() {\n"
        "      return this._changed && this._filled === this.values.length;\n"
        "    }\n"
        "    is(value) {\n"
        "      return this._endValue === value && this.done;\n"
        "    }\n"
        "    destroy() {\n"
        "      this._removeTableReference(this._tableKey);\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "    if (!ModuleScope.WamParameterInterpolator)\n"
        "      ModuleScope.WamParameterInterpolator = WamParameterInterpolator;\n"
        "  }\n"
        "  return WamParameterInterpolator;\n"
        "};\n"
        "var WamParameterInterpolator_default = getWamParameterInterpolator;\n"
        "\n"
        "// src/WamProcessor.js\n"
        "var getWamProcessor = (moduleId) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  const {\n"
        "    AudioWorkletProcessor,\n"
        "    webAudioModules\n"
        "  } = audioWorkletGlobalScope;\n"
        "  const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "  const {\n"
        "    RingBuffer: RingBuffer2,\n"
        "    WamEventRingBuffer: WamEventRingBuffer2,\n"
        "    WamParameter,\n"
        "    WamParameterInterpolator\n"
        "  } = ModuleScope;\n"
        "  class WamProcessor extends AudioWorkletProcessor {\n"
        "    constructor(options) {\n"
        "      super();\n"
        "      const {\n"
        "        groupId,\n"
        "        moduleId: moduleId2,\n"
        "        instanceId,\n"
        "        useSab\n"
        "      } = options.processorOptions;\n"
        "      if (!moduleId2)\n"
        "        throw Error(\"must provide moduleId argument in processorOptions!\");\n"
        "      if (!instanceId)\n"
        "        throw Error(\"must provide instanceId argument in processorOptions!\");\n"
        "      this.groupId = groupId;\n"
        "      this.moduleId = moduleId2;\n"
        "      this.instanceId = instanceId;\n"
        "      this._samplesPerQuantum = 128;\n"
        "      this._compensationDelay = 0;\n"
        "      this._parameterInfo = {};\n"
        "      this._parameterState = {};\n"
        "      this._parameterInterpolators = {};\n"
        "      this._eventQueue = [];\n"
        "      this._pendingResponses = {};\n"
        "      this._useSab = !!useSab && !!globalThis.SharedArrayBuffer;\n"
        "      this._eventSabReady = false;\n"
        "      this._audioToMainEventSab = null;\n"
        "      this._mainToAudioEventSab = null;\n"
        "      this._eventWriter = null;\n"
        "      this._eventReader = null;\n"
        "      this._initialized = false;\n"
        "      this._destroyed = false;\n"
        "      webAudioModules.addWam(this);\n"
        "      this.port.onmessage = this._onMessage.bind(this);\n"
        "      if (this._useSab)\n"
        "        this._configureSab();\n"
        "    }\n"
        "    getCompensationDelay() {\n"
        "      return this._compensationDelay;\n"
        "    }\n"
        "    scheduleEvents(...events) {\n"
        "      let i = 0;\n"
        "      while (i < events.length) {\n"
        "        this._eventQueue.push({ id: 0, event: events[i] });\n"
        "        i++;\n"
        "      }\n"
        "    }\n"
        "    emitEvents(...events) {\n"
        "      webAudioModules.emitEvents(this, ...events);\n"
        "    }\n"
        "    clearEvents() {\n"
        "      this._eventQueue = [];\n"
        "    }\n"
        "    process(inputs, outputs, parameters) {\n"
        "      if (!this._initialized)\n"
        "        return true;\n"
        "      if (this._destroyed)\n"
        "        return false;\n"
        "      if (this._eventSabReady)\n"
        "        this.scheduleEvents(...this._eventReader.read());\n"
        "      const processingSlices = this._getProcessingSlices();\n"
        "      let i = 0;\n"
        "      while (i < processingSlices.length) {\n"
        "        const { range, events } = processingSlices[i];\n"
        "        const [startSample, endSample] = range;\n"
        "        let j = 0;\n"
        "        while (j < events.length) {\n"
        "          this._processEvent(events[j]);\n"
        "          j++;\n"
        "        }\n"
        "        this._interpolateParameterValues(startSample, endSample);\n"
        "        this._process(startSample, endSample, inputs, outputs, parameters);\n"
        "        i++;\n"
        "      }\n"
        "      return true;\n"
        "    }\n"
        "    destroy() {\n"
        "      this._destroyed = true;\n"
        "      this.port.close();\n"
        "      webAudioModules.removeWam(this);\n"
        "    }\n"
        "    _generateWamParameterInfo() {\n"
        "      return {};\n"
        "    }\n"
        "    _initialize() {\n"
        "      this._parameterState = {};\n"
        "      this._parameterInterpolators = {};\n"
        "      this._parameterInfo = this._generateWamParameterInfo();\n"
        "      Object.keys(this._parameterInfo).forEach((parameterId) => {\n"
        "        const info = this._parameterInfo[parameterId];\n"
        "        this._parameterState[parameterId] = new WamParameter(this._parameterInfo[parameterId]);\n"
        "        this._parameterInterpolators[parameterId] = new WamParameterInterpolator(info, 256);\n"
        "      });\n"
        "    }\n"
        "    _configureSab() {\n"
        "      const eventCapacity = 2 ** 10;\n"
        "      const parameterIds = Object.keys(this._parameterInfo);\n"
        "      if (this._eventSabReady) {\n"
        "        this._eventWriter.setParameterIds(parameterIds);\n"
        "        this._eventReader.setParameterIds(parameterIds);\n"
        "      }\n"
        "      this.port.postMessage({ eventSab: { eventCapacity, parameterIds } });\n"
        "    }\n"
        "    async _onMessage(message) {\n"
        "      if (message.data.request) {\n"
        "        const {\n"
        "          id,\n"
        "          request,\n"
        "          content\n"
        "        } = message.data;\n"
        "        const response = { id, response: request };\n"
        "        const requestComponents = request.split(\"/\");\n"
        "        const verb = requestComponents[0];\n"
        "        const noun = requestComponents[1];\n"
        "        response.content = \"error\";\n"
        "        if (verb === \"get\") {\n"
        "          if (noun === \"parameterInfo\") {\n"
        "            let { parameterIds } = content;\n"
        "            if (!parameterIds.length)\n"
        "              parameterIds = Object.keys(this._parameterInfo);\n"
        "            const parameterInfo = {};\n"
        "            let i = 0;\n"
        "            while (i < parameterIds.length) {\n"
        "              const parameterId = parameterIds[i];\n"
        "              parameterInfo[parameterId] = this._parameterInfo[parameterId];\n"
        "              i++;\n"
        "            }\n"
        "            response.content = parameterInfo;\n"
        "          } else if (noun === \"parameterValues\") {\n"
        "            let { normalized, parameterIds } = content;\n"
        "            response.content = this._getParameterValues(normalized, parameterIds);\n"
        "          } else if (noun === \"state\") {\n"
        "            response.content = this._getState();\n"
        "          } else if (noun === \"compensationDelay\") {\n"
        "            response.content = this.getCompensationDelay();\n"
        "          }\n"
        "        } else if (verb === \"set\") {\n"
        "          if (noun === \"parameterValues\") {\n"
        "            const { parameterValues } = content;\n"
        "            this._setParameterValues(parameterValues, true);\n"
        "            delete response.content;\n"
        "          } else if (noun === \"state\") {\n"
        "            const { state } = content;\n"
        "            this._setState(state);\n"
        "            delete response.content;\n"
        "          }\n"
        "        } else if (verb === \"add\") {\n"
        "          if (noun === \"event\") {\n"
        "            const { event } = content;\n"
        "            this._eventQueue.push({ id, event });\n"
        "            return;\n"
        "          }\n"
        "        } else if (verb === \"remove\") {\n"
        "          if (noun === \"events\") {\n"
        "            const ids = this._eventQueue.map((queued) => queued.id);\n"
        "            this.clearEvents();\n"
        "            response.content = ids;\n"
        "          }\n"
        "        } else if (verb === \"connect\") {\n"
        "          if (noun === \"events\") {\n"
        "            const { wamInstanceId, output } = content;\n"
        "            this._connectEvents(wamInstanceId, output);\n"
        "            delete response.content;\n"
        "          }\n"
        "        } else if (verb === \"disconnect\") {\n"
        "          if (noun === \"events\") {\n"
        "            const { wamInstanceId, output } = content;\n"
        "            this._disconnectEvents(wamInstanceId, output);\n"
        "            delete response.content;\n"
        "          }\n"
        "        } else if (verb === \"initialize\") {\n"
        "          if (noun === \"processor\") {\n"
        "            this._initialize();\n"
        "            this._initialized = true;\n"
        "            delete response.content;\n"
        "          } else if (noun === \"eventSab\") {\n"
        "            const { mainToAudioEventSab, audioToMainEventSab } = content;\n"
        "            this._audioToMainEventSab = audioToMainEventSab;\n"
        "            this._mainToAudioEventSab = mainToAudioEventSab;\n"
        "            const parameterIds = Object.keys(this._parameterInfo);\n"
        "            this._eventWriter = new WamEventRingBuffer2(RingBuffer2, this._audioToMainEventSab, parameterIds);\n"
        "            this._eventReader = new WamEventRingBuffer2(RingBuffer2, this._mainToAudioEventSab, parameterIds);\n"
        "            this._eventSabReady = true;\n"
        "            delete response.content;\n"
        "          }\n"
        "        }\n"
        "        this.port.postMessage(response);\n"
        "      } else if (message.data.destroy) {\n"
        "        this.destroy();\n"
        "      }\n"
        "    }\n"
        "    _onTransport(transportData) {\n"
        "      console.error(\"_onTransport not implemented!\");\n"
        "    }\n"
        "    _onMidi(midiData) {\n"
        "      console.error(\"_onMidi not implemented!\");\n"
        "    }\n"
        "    _onSysex(sysexData) {\n"
        "      console.error(\"_onMidi not implemented!\");\n"
        "    }\n"
        "    _onMpe(mpeData) {\n"
        "      console.error(\"_onMpe not implemented!\");\n"
        "    }\n"
        "    _onOsc(oscData) {\n"
        "      console.error(\"_onOsc not implemented!\");\n"
        "    }\n"
        "    _setState(state) {\n"
        "      if (state.parameterValues)\n"
        "        this._setParameterValues(state.parameterValues, false);\n"
        "    }\n"
        "    _getState() {\n"
        "      return { parameterValues: this._getParameterValues(false) };\n"
        "    }\n"
        "    _getParameterValues(normalized, parameterIds) {\n"
        "      const parameterValues = {};\n"
        "      if (!parameterIds || !parameterIds.length)\n"
        "        parameterIds = Object.keys(this._parameterState);\n"
        "      let i = 0;\n"
        "      while (i < parameterIds.length) {\n"
        "        const id = parameterIds[i];\n"
        "        const parameter = this._parameterState[id];\n"
        "        parameterValues[id] = {\n"
        "          id,\n"
        "          value: normalized ? parameter.normalizedValue : parameter.value,\n"
        "          normalized\n"
        "        };\n"
        "        i++;\n"
        "      }\n"
        "      return parameterValues;\n"
        "    }\n"
        "    _setParameterValues(parameterUpdates, interpolate) {\n"
        "      const parameterIds = Object.keys(parameterUpdates);\n"
        "      let i = 0;\n"
        "      while (i < parameterIds.length) {\n"
        "        this._setParameterValue(parameterUpdates[parameterIds[i]], interpolate);\n"
        "        i++;\n"
        "      }\n"
        "    }\n"
        "    _setParameterValue(parameterUpdate, interpolate) {\n"
        "      const { id, value, normalized } = parameterUpdate;\n"
        "      const parameter = this._parameterState[id];\n"
        "      if (!parameter)\n"
        "        return;\n"
        "      if (!normalized)\n"
        "        parameter.value = value;\n"
        "      else\n"
        "        parameter.normalizedValue = value;\n"
        "      const interpolator = this._parameterInterpolators[id];\n"
        "      if (interpolate)\n"
        "        interpolator.setEndValue(parameter.value);\n"
        "      else\n"
        "        interpolator.setStartValue(parameter.value);\n"
        "    }\n"
        "    _interpolateParameterValues(startIndex, endIndex) {\n"
        "      const parameterIds = Object.keys(this._parameterInterpolators);\n"
        "      let i = 0;\n"
        "      while (i < parameterIds.length) {\n"
        "        this._parameterInterpolators[parameterIds[i]].process(startIndex, endIndex);\n"
        "        i++;\n"
        "      }\n"
        "    }\n"
        "    _connectEvents(wamInstanceId, output) {\n"
        "      webAudioModules.connectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n"
        "    }\n"
        "    _disconnectEvents(wamInstanceId, output) {\n"
        "      if (typeof wamInstanceId === \"undefined\") {\n"
        "        webAudioModules.disconnectEvents(this.groupId, this.instanceId);\n"
        "        return;\n"
        "      }\n"
        "      webAudioModules.disconnectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n"
        "    }\n"
        "    _getProcessingSlices() {\n"
        "      const response = \"add/event\";\n"
        "      const { currentTime, sampleRate } = audioWorkletGlobalScope;\n"
        "      const eventsBySampleIndex = {};\n"
        "      let i = 0;\n"
        "      while (i < this._eventQueue.length) {\n"
        "        const { id, event } = this._eventQueue[i];\n"
        "        const offsetSec = event.time - currentTime;\n"
        "        const sampleIndex = offsetSec > 0 ? Math.round(offsetSec * sampleRate) : 0;\n"
        "        if (sampleIndex < this._samplesPerQuantum) {\n"
        "          if (eventsBySampleIndex[sampleIndex])\n"
        "            eventsBySampleIndex[sampleIndex].push(event);\n"
        "          else\n"
        "            eventsBySampleIndex[sampleIndex] = [event];\n"
        "          if (id)\n"
        "            this.port.postMessage({ id, response });\n"
        "          else if (this._eventSabReady)\n"
        "            this._eventWriter.write(event);\n"
        "          else\n"
        "            this.port.postMessage({ event });\n"
        "          this._eventQueue.shift();\n"
        "          i = -1;\n"
        "        } else\n"
        "          break;\n"
        "        i++;\n"
        "      }\n"
        "      const processingSlices = [];\n"
        "      const keys = Object.keys(eventsBySampleIndex);\n"
        "      if (keys[0] !== \"0\") {\n"
        "        keys.unshift(\"0\");\n"
        "        eventsBySampleIndex[\"0\"] = [];\n"
        "      }\n"
        "      const lastIndex = keys.length - 1;\n"
        "      i = 0;\n"
        "      while (i < keys.length) {\n"
        "        const key = keys[i];\n"
        "        const startSample = parseInt(key);\n"
        "        const endSample = i < lastIndex ? parseInt(keys[i + 1]) : this._samplesPerQuantum;\n"
        "        processingSlices.push({ range: [startSample, endSample], events: eventsBySampleIndex[key] });\n"
        "        i++;\n"
        "      }\n"
        "      return processingSlices;\n"
        "    }\n"
        "    _processEvent(event) {\n"
        "      switch (event.type) {\n"
        "        case \"wam-automation\":\n"
        "          this._setParameterValue(event.data, true);\n"
        "          break;\n"
        "        case \"wam-transport\":\n"
        "          this._onTransport(event.data);\n"
        "          break;\n"
        "        case \"wam-midi\":\n"
        "          this._onMidi(event.data);\n"
        "          break;\n"
        "        case \"wam-sysex\":\n"
        "          this._onSysex(event.data);\n"
        "          break;\n"
        "        case \"wam-mpe\":\n"
        "          this._onMpe(event.data);\n"
        "          break;\n"
        "        case \"wam-osc\":\n"
        "          this._onOsc(event.data);\n"
        "          break;\n"
        "        default:\n"
        "          break;\n"
        "      }\n"
        "    }\n"
        "    _process(startSample, endSample, inputs, outputs, parameters) {\n"
        "      console.error(\"_process not implemented!\");\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    if (!ModuleScope.WamProcessor)\n"
        "      ModuleScope.WamProcessor = WamProcessor;\n"
        "  }\n"
        "  return WamProcessor;\n"
        "};\n"
        "var WamProcessor_default = getWamProcessor;\n"
        "\n"
        "// src/WamNode.js\n"
        "var RingBuffer = RingBuffer_default();\n"
        "var WamEventRingBuffer = WamEventRingBuffer_default();\n"
        "var WamNode = class extends AudioWorkletNode {\n"
        "  static async addModules(audioContext, moduleId) {\n"
        "    const { audioWorklet } = audioContext;\n"
        "    await addFunctionModule_default(audioWorklet, RingBuffer_default, moduleId);\n"
        "    await addFunctionModule_default(audioWorklet, WamEventRingBuffer_default, moduleId);\n"
        "    await addFunctionModule_default(audioWorklet, WamArrayRingBuffer_default, moduleId);\n"
        "    await addFunctionModule_default(audioWorklet, WamParameter_default, moduleId);\n"
        "    await addFunctionModule_default(audioWorklet, WamParameterInfo_default, moduleId);\n"
        "    await addFunctionModule_default(audioWorklet, WamParameterInterpolator_default, moduleId);\n"
        "    await addFunctionModule_default(audioWorklet, WamProcessor_default, moduleId);\n"
        "  }\n"
        "  constructor(module, options) {\n"
        "    const { audioContext, groupId, moduleId, instanceId } = module;\n"
        "    options.processorOptions = {\n"
        "      groupId,\n"
        "      moduleId,\n"
        "      instanceId,\n"
        "      ...options.processorOptions\n"
        "    };\n"
        "    super(audioContext, moduleId, options);\n"
        "    this.module = module;\n"
        "    this._supportedEventTypes = /* @__PURE__ */ new Set([\"wam-automation\", \"wam-transport\", \"wam-midi\", \"wam-sysex\", \"wam-mpe\", \"wam-osc\"]);\n"
        "    this._messageId = 1;\n"
        "    this._pendingResponses = {};\n"
        "    this._pendingEvents = {};\n"
        "    this._useSab = false;\n"
        "    this._eventSabReady = false;\n"
        "    this._destroyed = false;\n"
        "    this.port.onmessage = this._onMessage.bind(this);\n"
        "  }\n"
        "  get groupId() {\n"
        "    return this.module.groupId;\n"
        "  }\n"
        "  get moduleId() {\n"
        "    return this.module.moduleId;\n"
        "  }\n"
        "  get instanceId() {\n"
        "    return this.module.instanceId;\n"
        "  }\n"
        "  async getParameterInfo(...parameterIds) {\n"
        "    const request = \"get/parameterInfo\";\n"
        "    const id = this._generateMessageId();\n"
        "    return new Promise((resolve) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({\n"
        "        id,\n"
        "        request,\n"
        "        content: { parameterIds }\n"
        "      });\n"
        "    });\n"
        "  }\n"
        "  async getParameterValues(normalized, ...parameterIds) {\n"
        "    const request = \"get/parameterValues\";\n"
        "    const id = this._generateMessageId();\n"
        "    return new Promise((resolve) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({\n"
        "        id,\n"
        "        request,\n"
        "        content: { normalized, parameterIds }\n"
        "      });\n"
        "    });\n"
        "  }\n"
        "  async setParameterValues(parameterValues) {\n"
        "    const request = \"set/parameterValues\";\n"
        "    const id = this._generateMessageId();\n"
        "    return new Promise((resolve) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({\n"
        "        id,\n"
        "        request,\n"
        "        content: { parameterValues }\n"
        "      });\n"
        "    });\n"
        "  }\n"
        "  async getState() {\n"
        "    const request = \"get/state\";\n"
        "    const id = this._generateMessageId();\n"
        "    return new Promise((resolve) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({ id, request });\n"
        "    });\n"
        "  }\n"
        "  async setState(state) {\n"
        "    const request = \"set/state\";\n"
        "    const id = this._generateMessageId();\n"
        "    return new Promise((resolve) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({\n"
        "        id,\n"
        "        request,\n"
        "        content: { state }\n"
        "      });\n"
        "    });\n"
        "  }\n"
        "  async getCompensationDelay() {\n"
        "    const request = \"get/compensationDelay\";\n"
        "    const id = this._generateMessageId();\n"
        "    return new Promise((resolve) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({ id, request });\n"
        "    });\n"
        "  }\n"
        "  addEventListener(type, callback, options) {\n"
        "    if (this._supportedEventTypes.has(type))\n"
        "      super.addEventListener(type, callback, options);\n"
        "  }\n"
        "  removeEventListener(type, callback, options) {\n"
        "    if (this._supportedEventTypes.has(type))\n"
        "      super.removeEventListener(type, callback, options);\n"
        "  }\n"
        "  scheduleEvents(...events) {\n"
        "    let i = 0;\n"
        "    const numEvents = events.length;\n"
        "    if (this._eventSabReady) {\n"
        "      i = this._eventWriter.write(...events);\n"
        "    }\n"
        "    while (i < numEvents) {\n"
        "      const event = events[i];\n"
        "      const request = \"add/event\";\n"
        "      const id = this._generateMessageId();\n"
        "      let processed = false;\n"
        "      new Promise((resolve, reject) => {\n"
        "        this._pendingResponses[id] = resolve;\n"
        "        this._pendingEvents[id] = () => {\n"
        "          if (!processed)\n"
        "            reject();\n"
        "        };\n"
        "        this.port.postMessage({\n"
        "          id,\n"
        "          request,\n"
        "          content: { event }\n"
        "        });\n"
        "      }).then((resolved) => {\n"
        "        processed = true;\n"
        "        delete this._pendingEvents[id];\n"
        "        this._onEvent(event);\n"
        "      }).catch((rejected) => {\n"
        "        delete this._pendingResponses[id];\n"
        "      });\n"
        "      i++;\n"
        "    }\n"
        "  }\n"
        "  async clearEvents() {\n"
        "    const request = \"remove/events\";\n"
        "    const id = this._generateMessageId();\n"
        "    const ids = Object.keys(this._pendingEvents);\n"
        "    if (ids.length) {\n"
        "      return new Promise((resolve) => {\n"
        "        this._pendingResponses[id] = resolve;\n"
        "        this.port.postMessage({ id, request });\n"
        "      }).then((clearedIds) => {\n"
        "        clearedIds.forEach((clearedId) => {\n"
        "          this._pendingEvents[clearedId]();\n"
        "          delete this._pendingEvents[clearedId];\n"
        "        });\n"
        "      });\n"
        "    }\n"
        "  }\n"
        "  connectEvents(toId, output) {\n"
        "    const request = \"connect/events\";\n"
        "    const id = this._generateMessageId();\n"
        "    new Promise((resolve, reject) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({\n"
        "        id,\n"
        "        request,\n"
        "        content: { wamInstanceId: toId, output }\n"
        "      });\n"
        "    });\n"
        "  }\n"
        "  disconnectEvents(toId, output) {\n"
        "    const request = \"disconnect/events\";\n"
        "    const id = this._generateMessageId();\n"
        "    new Promise((resolve, reject) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({\n"
        "        id,\n"
        "        request,\n"
        "        content: { wamInstanceId: toId, output }\n"
        "      });\n"
        "    });\n"
        "  }\n"
        "  destroy() {\n"
        "    if (this._audioToMainInterval)\n"
        "      clearInterval(this._audioToMainInterval);\n"
        "    this.port.postMessage({ destroy: true });\n"
        "    this.port.close();\n"
        "    this.disconnect();\n"
        "    this._destroyed = true;\n"
        "  }\n"
        "  _generateMessageId() {\n"
        "    return this._messageId++;\n"
        "  }\n"
        "  async _initialize() {\n"
        "    const request = \"initialize/processor\";\n"
        "    const id = this._generateMessageId();\n"
        "    return new Promise((resolve) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({ id, request });\n"
        "    });\n"
        "  }\n"
        "  _onMessage(message) {\n"
        "    const { data } = message;\n"
        "    const { response, event, eventSab } = data;\n"
        "    if (response) {\n"
        "      const { id, content } = data;\n"
        "      const resolvePendingResponse = this._pendingResponses[id];\n"
        "      if (resolvePendingResponse) {\n"
        "        delete this._pendingResponses[id];\n"
        "        resolvePendingResponse(content);\n"
        "      }\n"
        "    } else if (eventSab) {\n"
        "      this._useSab = true;\n"
        "      const { eventCapacity, parameterIds } = eventSab;\n"
        "      if (this._eventSabReady) {\n"
        "        this._eventWriter.setParameterIds(parameterIds);\n"
        "        this._eventReader.setParameterIds(parameterIds);\n"
        "        return;\n"
        "      }\n"
        "      this._mainToAudioEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer, eventCapacity);\n"
        "      this._audioToMainEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer, eventCapacity);\n"
        "      this._eventWriter = new WamEventRingBuffer(RingBuffer, this._mainToAudioEventSab, parameterIds);\n"
        "      this._eventReader = new WamEventRingBuffer(RingBuffer, this._audioToMainEventSab, parameterIds);\n"
        "      const request = \"initialize/eventSab\";\n"
        "      const id = this._generateMessageId();\n"
        "      new Promise((resolve, reject) => {\n"
        "        this._pendingResponses[id] = resolve;\n"
        "        this.port.postMessage({\n"
        "          id,\n"
        "          request,\n"
        "          content: {\n"
        "            mainToAudioEventSab: this._mainToAudioEventSab,\n"
        "            audioToMainEventSab: this._audioToMainEventSab\n"
        "          }\n"
        "        });\n"
        "      }).then((resolved) => {\n"
        "        this._eventSabReady = true;\n"
        "        this._audioToMainInterval = setInterval(() => {\n"
        "          const events = this._eventReader.read();\n"
        "          events.forEach((e) => {\n"
        "            this._onEvent(e);\n"
        "          });\n"
        "        }, 100);\n"
        "      });\n"
        "    } else if (event)\n"
        "      this._onEvent(event);\n"
        "  }\n"
        "  _onEvent(event) {\n"
        "    const { type } = event;\n"
        "    this.dispatchEvent(new CustomEvent(type, {\n"
        "      bubbles: true,\n"
        "      detail: event\n"
        "    }));\n"
        "  }\n"
        "};\n"
        "\n"
        "// src/apiVersion.js\n"
        "var apiVersion_default = \"2.0.0-alpha.6\";\n"
        "\n"
        "// src/initializeWamHost.js\n"
        "var initializeWamHost = async (audioContext, hostGroupId = `wam-host-${performance.now().toString()}`, hostGroupKey = performance.now().toString()) => {\n"
        "  await addFunctionModule_default(audioContext.audioWorklet, WamEnv_default, apiVersion_default);\n"
        "  await addFunctionModule_default(audioContext.audioWorklet, WamGroup_default, hostGroupId, hostGroupKey);\n"
        "  return [hostGroupId, hostGroupKey];\n"
        "};\n"
        "var initializeWamHost_default = initializeWamHost;\n"
        "export {\n"
        "  WamNode,\n"
        "  WebAudioModule_default as WebAudioModule,\n"
        "  addFunctionModule_default as addFunctionModule,\n"
        "  apiVersion_default as apiVersion,\n"
        "  RingBuffer_default as getRingBuffer,\n"
        "  WamArrayRingBuffer_default as getWamArrayRingBuffer,\n"
        "  WamEventRingBuffer_default as getWamEventRingBuffer,\n"
        "  WamParameter_default as getWamParameter,\n"
        "  WamParameterInfo_default as getWamParameterInfo,\n"
        "  WamParameterInterpolator_default as getWamParameterInterpolator,\n"
        "  WamProcessor_default as getWamProcessor,\n"
        "  WamEnv_default as initializeWamEnv,\n"
        "  WamGroup_default as initializeWamGroup,\n"
        "  initializeWamHost_default as initializeWamHost\n"
        "};\n"
        "//# sourceMappingURL=index.js.map\n";


    static constexpr std::array files =
    {
        File { "sdk/index.js", std::string_view (sdk_index_js, 59572) }
    };

};

} // namespace cmaj
