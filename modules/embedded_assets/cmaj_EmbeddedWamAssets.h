//
//     ,ad888ba,                              88
//    d8"'    "8b
//   d8            88,dba,,adba,   ,aPP8A.A8  88     The Cmajor Toolkit
//   Y8,           88    88    88  88     88  88
//    Y8a.   .a8P  88    88    88  88,   ,88  88     (C)2024 Cmajor Software Ltd
//     '"Y888Y"'   88    88    88  '"8bbP"Y8  88     https://cmajor.dev
//                                           ,88
//                                        888P"
//
//  Cmajor may be used under the terms of the ISC license:
//
//  Permission to use, copy, modify, and/or distribute this software for any purpose with or
//  without fee is hereby granted, provided that the above copyright notice and this permission
//  notice appear in all copies. THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
//  WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
//  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
//  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
//  CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#pragma once

#include <array>
#include <string_view>

namespace cmaj
{

/// This contains the javascript support classes for web audio modules
///
struct EmbeddedWamAssets
{
    static std::string_view findResource (std::string_view path)
    {
        for (auto& file : files)
            if (path == file.name)
                return file.content;

        return {};
    }

    struct File { std::string_view name, content; };

    static constexpr const char* sdk_parammgr_js = "var __defProp = Object.defineProperty;\n"
        "var __defProps = Object.defineProperties;\n"
        "var __getOwnPropDescs = Object.getOwnPropertyDescriptors;\n"
        "var __getOwnPropSymbols = Object.getOwnPropertySymbols;\n"
        "var __hasOwnProp = Object.prototype.hasOwnProperty;\n"
        "var __propIsEnum = Object.prototype.propertyIsEnumerable;\n"
        "var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n"
        "var __spreadValues = (a, b) => {\n"
        "  for (var prop in b || (b = {}))\n"
        "    if (__hasOwnProp.call(b, prop))\n"
        "      __defNormalProp(a, prop, b[prop]);\n"
        "  if (__getOwnPropSymbols)\n"
        "    for (var prop of __getOwnPropSymbols(b)) {\n"
        "      if (__propIsEnum.call(b, prop))\n"
        "        __defNormalProp(a, prop, b[prop]);\n"
        "    }\n"
        "  return a;\n"
        "};\n"
        "var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n"
        "var __publicField = (obj, key, value) => {\n"
        "  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n"
        "  return value;\n"
        "};\n"
        "\n"
        "// src/CompositeAudioNode.js\n"
        "var CompositeAudioNode = class extends GainNode {\n"
        "  constructor() {\n"
        "    super(...arguments);\n"
        "    /**\n"
        "     * @type {AudioNode}\n"
        "     */\n"
        "    __publicField(this, \"_output\");\n"
        "    /**\n"
        "     * @type {WamNode}\n"
        "     */\n"
        "    __publicField(this, \"_wamNode\");\n"
        "  }\n"
        "  get groupId() {\n"
        "    return this.module.groupId;\n"
        "  }\n"
        "  get moduleId() {\n"
        "    return this.module.moduleId;\n"
        "  }\n"
        "  get instanceId() {\n"
        "    return this.module.instanceId;\n"
        "  }\n"
        "  get module() {\n"
        "    return this._wamNode.module;\n"
        "  }\n"
        "  /**\n"
        "   * @param {Parameters<WamNode['addEventListener']>} args\n"
        "   */\n"
        "  addEventListener(...args) {\n"
        "    return this._wamNode.addEventListener(...args);\n"
        "  }\n"
        "  /**\n"
        "   * @param {Parameters<WamNode['removeEventListener']>} args\n"
        "   */\n"
        "  removeEventListener(...args) {\n"
        "    return this._wamNode.removeEventListener(...args);\n"
        "  }\n"
        "  /**\n"
        "   * @param {Parameters<WamNode['dispatchEvent']>} args\n"
        "   */\n"
        "  dispatchEvent(...args) {\n"
        "    return this._wamNode.dispatchEvent(...args);\n"
        "  }\n"
        "  /**\n"
        "   * @param {Parameters<WamNode['getParameterInfo']>} args\n"
        "   */\n"
        "  getParameterInfo(...args) {\n"
        "    return this._wamNode.getParameterInfo(...args);\n"
        "  }\n"
        "  /**\n"
        "   * @param {Parameters<WamNode['getParameterValues']>} args\n"
        "   */\n"
        "  getParameterValues(...args) {\n"
        "    return this._wamNode.getParameterValues(...args);\n"
        "  }\n"
        "  /**\n"
        "   * @param {Parameters<WamNode['setParameterValues']>} args\n"
        "   */\n"
        "  setParameterValues(...args) {\n"
        "    return this._wamNode.setParameterValues(...args);\n"
        "  }\n"
        "  getState() {\n"
        "    return this._wamNode.getState();\n"
        "  }\n"
        "  /**\n"
        "   * @param {Parameters<WamNode['setState']>} args\n"
        "   */\n"
        "  setState(...args) {\n"
        "    return this._wamNode.setState(...args);\n"
        "  }\n"
        "  getCompensationDelay() {\n"
        "    return this._wamNode.getCompensationDelay();\n"
        "  }\n"
        "  /**\n"
        "   * @param {Parameters<WamNode['scheduleEvents']>} args\n"
        "   */\n"
        "  scheduleEvents(...args) {\n"
        "    return this._wamNode.scheduleEvents(...args);\n"
        "  }\n"
        "  clearEvents() {\n"
        "    return this._wamNode.clearEvents();\n"
        "  }\n"
        "  /**\n"
        "   * @param {Parameters<WamNode['connectEvents']>} args\n"
        "   */\n"
        "  connectEvents(...args) {\n"
        "    return this._wamNode.connectEvents(...args);\n"
        "  }\n"
        "  /**\n"
        "   * @param {Parameters<WamNode['disconnectEvents']>} args\n"
        "   */\n"
        "  disconnectEvents(...args) {\n"
        "    return this._wamNode.disconnectEvents(...args);\n"
        "  }\n"
        "  destroy() {\n"
        "    return this._wamNode.destroy();\n"
        "  }\n"
        "  set channelCount(count) {\n"
        "    if (this._output)\n"
        "      this._output.channelCount = count;\n"
        "    else\n"
        "      super.channelCount = count;\n"
        "  }\n"
        "  get channelCount() {\n"
        "    if (this._output)\n"
        "      return this._output.channelCount;\n"
        "    return super.channelCount;\n"
        "  }\n"
        "  set channelCountMode(mode) {\n"
        "    if (this._output)\n"
        "      this._output.channelCountMode = mode;\n"
        "    else\n"
        "      super.channelCountMode = mode;\n"
        "  }\n"
        "  get channelCountMode() {\n"
        "    if (this._output)\n"
        "      return this._output.channelCountMode;\n"
        "    return super.channelCountMode;\n"
        "  }\n"
        "  set channelInterpretation(interpretation) {\n"
        "    if (this._output)\n"
        "      this._output.channelInterpretation = interpretation;\n"
        "    else\n"
        "      super.channelInterpretation = interpretation;\n"
        "  }\n"
        "  get channelInterpretation() {\n"
        "    if (this._output)\n"
        "      return this._output.channelInterpretation;\n"
        "    return super.channelInterpretation;\n"
        "  }\n"
        "  get numberOfInputs() {\n"
        "    return super.numberOfInputs;\n"
        "  }\n"
        "  get numberOfOutputs() {\n"
        "    if (this._output)\n"
        "      return this._output.numberOfOutputs;\n"
        "    return super.numberOfOutputs;\n"
        "  }\n"
        "  get gain() {\n"
        "    return void 0;\n"
        "  }\n"
        "  connect(...args) {\n"
        "    if (this._output && this._output !== this)\n"
        "      return this._output.connect(...args);\n"
        "    return super.connect(...args);\n"
        "  }\n"
        "  disconnect(...args) {\n"
        "    if (this._output && this._output !== this)\n"
        "      return this._output.disconnect(...args);\n"
        "    return super.disconnect(...args);\n"
        "  }\n"
        "};\n"
        "\n"
        "// src/sdk/src/addFunctionModule.js\n"
        "var addFunctionModule = (audioWorklet, processorFunction, ...injection) => {\n"
        "  const text = `(${processorFunction.toString()})(${injection.map((s) => JSON.stringify(s)).join(\", \")});`;\n"
        "  const url = URL.createObjectURL(new Blob([text], { type: \"text/javascript\" }));\n"
        "  return audioWorklet.addModule(url);\n"
        "};\n"
        "var addFunctionModule_default = addFunctionModule;\n"
        "\n"
        "// src/ParamMgrProcessor.js\n"
        "var processor = (moduleId, paramsConfig) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  const {\n"
        "    AudioWorkletProcessor,\n"
        "    registerProcessor,\n"
        "    webAudioModules\n"
        "  } = audioWorkletGlobalScope;\n"
        "  const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "  const supportSharedArrayBuffer = !!globalThis.SharedArrayBuffer;\n"
        "  const SharedArrayBuffer = globalThis.SharedArrayBuffer || globalThis.ArrayBuffer;\n"
        "  const normExp = (x, e) => e === 0 ? x : x ** 1.5 ** -e;\n"
        "  const normalizeE = (x, min, max, e = 0) => min === 0 && max === 1 ? normExp(x, e) : normExp((x - min) / (max - min) || 0, e);\n"
        "  const normalize = (x, min, max) => min === 0 && max === 1 ? x : (x - min) / (max - min) || 0;\n"
        "  const denormalize = (x, min, max) => min === 0 && max === 1 ? x : x * (max - min) + min;\n"
        "  const mapValue = (x, eMin, eMax, sMin, sMax, tMin, tMax) => denormalize(\n"
        "    normalize(\n"
        "      normalize(\n"
        "        Math.min(sMax, Math.max(sMin, x)),\n"
        "        eMin,\n"
        "        eMax\n"
        "      ),\n"
        "      normalize(sMin, eMin, eMax),\n"
        "      normalize(sMax, eMin, eMax)\n"
        "    ),\n"
        "    tMin,\n"
        "    tMax\n"
        "  );\n"
        "  class ParamMgrProcessor extends AudioWorkletProcessor {\n"
        "    static get parameterDescriptors() {\n"
        "      return Object.entries(paramsConfig).map(([name, { defaultValue, minValue, maxValue }]) => ({\n"
        "        name,\n"
        "        defaultValue,\n"
        "        minValue,\n"
        "        maxValue\n"
        "      }));\n"
        "    }\n"
        "    /**\n"
        "     * @param {ParamMgrProcessorOptions} options\n"
        "     */\n"
        "    constructor(options) {\n"
        "      super();\n"
        "      this.destroyed = false;\n"
        "      this.supportSharedArrayBuffer = supportSharedArrayBuffer;\n"
        "      const {\n"
        "        paramsMapping,\n"
        "        internalParamsMinValues,\n"
        "        internalParams,\n"
        "        groupId,\n"
        "        instanceId\n"
        "      } = options.processorOptions;\n"
        "      this.groupId = groupId;\n"
        "      this.moduleId = moduleId;\n"
        "      this.instanceId = instanceId;\n"
        "      this.internalParamsMinValues = internalParamsMinValues;\n"
        "      this.paramsConfig = paramsConfig;\n"
        "      this.paramsMapping = paramsMapping;\n"
        "      this.paramsValues = {};\n"
        "      Object.entries(paramsConfig).forEach(([name, { defaultValue }]) => {\n"
        "        this.paramsValues[name] = defaultValue;\n"
        "      });\n"
        "      this.internalParams = internalParams;\n"
        "      this.internalParamsCount = this.internalParams.length;\n"
        "      this.buffer = new SharedArrayBuffer((this.internalParamsCount + 1) * Float32Array.BYTES_PER_ELEMENT);\n"
        "      this.$lock = new Int32Array(this.buffer, 0, 1);\n"
        "      this.$internalParamsBuffer = new Float32Array(this.buffer, 4, this.internalParamsCount);\n"
        "      this.eventQueue = [];\n"
        "      this.handleEvent = null;\n"
        "      audioWorkletGlobalScope.webAudioModules.addWam(this);\n"
        "      if (!ModuleScope.paramMgrProcessors)\n"
        "        ModuleScope.paramMgrProcessors = {};\n"
        "      ModuleScope.paramMgrProcessors[this.instanceId] = this;\n"
        "      this.messagePortRequestId = -1;\n"
        "      const resolves = {};\n"
        "      const rejects = {};\n"
        "      this.call = (call, ...args) => new Promise((resolve, reject) => {\n"
        "        const id = this.messagePortRequestId--;\n"
        "        resolves[id] = resolve;\n"
        "        rejects[id] = reject;\n"
        "        this.port.postMessage({ id, call, args });\n"
        "      });\n"
        "      this.handleMessage = ({ data }) => {\n"
        "        var _a, _b;\n"
        "        const { id, call, args, value, error } = data;\n"
        "        if (call) {\n"
        "          const r = { id };\n"
        "          try {\n"
        "            r.value = this[call](...args);\n"
        "          } catch (e) {\n"
        "            r.error = e;\n"
        "          }\n"
        "          this.port.postMessage(r);\n"
        "        } else {\n"
        "          if (error)\n"
        "            (_a = rejects[id]) == null ? void 0 : _a.call(rejects, error);\n"
        "          else\n"
        "            (_b = resolves[id]) == null ? void 0 : _b.call(resolves, value);\n"
        "          delete resolves[id];\n"
        "          delete rejects[id];\n"
        "        }\n"
        "      };\n"
        "      this.port.start();\n"
        "      this.port.addEventListener(\"message\", this.handleMessage);\n"
        "    }\n"
        "    /**\n"
        "     * @param {ParametersMapping} mapping\n"
        "     */\n"
        "    setParamsMapping(mapping) {\n"
        "      this.paramsMapping = mapping;\n"
        "    }\n"
        "    getBuffer() {\n"
        "      return { lock: this.$lock, paramsBuffer: this.$internalParamsBuffer };\n"
        "    }\n"
        "    getCompensationDelay() {\n"
        "      return 128;\n"
        "    }\n"
        "    /**\n"
        "     * @param {string[]} parameterIdQuery\n"
        "     */\n"
        "    getParameterInfo(...parameterIdQuery) {\n"
        "      if (parameterIdQuery.length === 0)\n"
        "        parameterIdQuery = Object.keys(this.paramsConfig);\n"
        "      const parameterInfo = {};\n"
        "      parameterIdQuery.forEach((parameterId) => {\n"
        "        parameterInfo[parameterId] = this.paramsConfig[parameterId];\n"
        "      });\n"
        "      return parameterInfo;\n"
        "    }\n"
        "    /**\n"
        "     * @param {boolean} [normalized]\n"
        "     * @param {string[]} parameterIdQuery\n"
        "     */\n"
        "    getParameterValues(normalized, ...parameterIdQuery) {\n"
        "      if (parameterIdQuery.length === 0)\n"
        "        parameterIdQuery = Object.keys(this.paramsConfig);\n"
        "      const parameterValues = {};\n"
        "      parameterIdQuery.forEach((parameterId) => {\n"
        "        if (!(parameterId in this.paramsValues))\n"
        "          return;\n"
        "        const { minValue, maxValue, exponent } = this.paramsConfig[parameterId];\n"
        "        const value = this.paramsValues[parameterId];\n"
        "        parameterValues[parameterId] = {\n"
        "          id: parameterId,\n"
        "          value: normalized ? normalizeE(value, minValue, maxValue, exponent) : value,\n"
        "          normalized\n"
        "        };\n"
        "      });\n"
        "      return parameterValues;\n"
        "    }\n"
        "    /**\n"
        "     * @param {WamEvent[]} events\n"
        "     */\n"
        "    scheduleEvents(...events) {\n"
        "      this.eventQueue.push(...events);\n"
        "      const { currentTime } = audioWorkletGlobalScope;\n"
        "      this.eventQueue.sort((a, b) => (a.time || currentTime) - (b.time || currentTime));\n"
        "    }\n"
        "    /**\n"
        "     * @param {WamEvent[]} events\n"
        "     */\n"
        "    emitEvents(...events) {\n"
        "      webAudioModules.emitEvents(this, ...events);\n"
        "    }\n"
        "    clearEvents() {\n"
        "      this.eventQueue = [];\n"
        "    }\n"
        "    lock() {\n"
        "      if (globalThis.Atomics)\n"
        "        Atomics.store(this.$lock, 0, 1);\n"
        "    }\n"
        "    unlock() {\n"
        "      if (globalThis.Atomics)\n"
        "        Atomics.store(this.$lock, 0, 0);\n"
        "    }\n"
        "    /**\n"
        "     * Main process\n"
        "     *\n"
        "     * @param {Float32Array[][]} inputs\n"
        "     * @param {Float32Array[][]} outputs\n"
        "     * @param {Record<string, Float32Array>} parameters\n"
        "     */\n"
        "    process(inputs, outputs, parameters) {\n"
        "      if (this.destroyed)\n"
        "        return false;\n"
        "      const outputOffset = 1;\n"
        "      this.lock();\n"
        "      Object.entries(this.paramsConfig).forEach(([name, { minValue, maxValue }]) => {\n"
        "        const raw = parameters[name];\n"
        "        if (name in this.paramsValues)\n"
        "          this.paramsValues[name] = raw[raw.length - 1];\n"
        "        if (!this.paramsMapping[name])\n"
        "          return;\n"
        "        Object.entries(this.paramsMapping[name]).forEach(([targetName, targetMapping]) => {\n"
        "          var _a, _b;\n"
        "          const j = this.internalParams.indexOf(targetName);\n"
        "          if (j === -1)\n"
        "            return;\n"
        "          const intrinsicValue = this.internalParamsMinValues[j];\n"
        "          const { sourceRange, targetRange } = targetMapping;\n"
        "          const [sMin, sMax] = sourceRange;\n"
        "          const [tMin, tMax] = targetRange;\n"
        "          let out;\n"
        "          if (minValue !== tMin || maxValue !== tMax || minValue !== sMin || maxValue !== sMax) {\n"
        "            out = raw.map((v) => {\n"
        "              const mappedValue = mapValue(v, minValue, maxValue, sMin, sMax, tMin, tMax);\n"
        "              return mappedValue - intrinsicValue;\n"
        "            });\n"
        "          } else if (intrinsicValue) {\n"
        "            out = raw.map((v) => v - intrinsicValue);\n"
        "          } else {\n"
        "            out = raw;\n"
        "          }\n"
        "          if (out.length === 1)\n"
        "            (_a = outputs[j + outputOffset][0]) == null ? void 0 : _a.fill(out[0]);\n"
        "          else\n"
        "            (_b = outputs[j + outputOffset][0]) == null ? void 0 : _b.set(out);\n"
        "          this.$internalParamsBuffer[j] = out[0];\n"
        "        });\n"
        "      });\n"
        "      this.unlock();\n"
        "      if (!this.supportSharedArrayBuffer) {\n"
        "        this.call(\"setBuffer\", { lock: this.$lock, paramsBuffer: this.$internalParamsBuffer });\n"
        "      }\n"
        "      const { currentTime } = audioWorkletGlobalScope;\n"
        "      let $event;\n"
        "      for ($event = 0; $event < this.eventQueue.length; $event++) {\n"
        "        const event = this.eventQueue[$event];\n"
        "        if (event.time && event.time > currentTime)\n"
        "          break;\n"
        "        if (typeof this.handleEvent === \"function\")\n"
        "          this.handleEvent(event);\n"
        "        this.call(\"dispatchWamEvent\", event);\n"
        "      }\n"
        "      if ($event)\n"
        "        this.eventQueue.splice(0, $event);\n"
        "      return true;\n"
        "    }\n"
        "    /**\n"
        "     * @param {string} wamInstanceId\n"
        "     * @param {number} [output]\n"
        "     */\n"
        "    connectEvents(wamInstanceId, output) {\n"
        "      webAudioModules.connectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n"
        "    }\n"
        "    /**\n"
        "     * @param {string} [wamInstanceId]\n"
        "     * @param {number} [output]\n"
        "     */\n"
        "    disconnectEvents(wamInstanceId, output) {\n"
        "      if (typeof wamInstanceId === \"undefined\") {\n"
        "        webAudioModules.disconnectEvents(this.groupId, this.instanceId);\n"
        "        return;\n"
        "      }\n"
        "      webAudioModules.disconnectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n"
        "    }\n"
        "    destroy() {\n"
        "      audioWorkletGlobalScope.webAudioModules.removeWam(this);\n"
        "      if (ModuleScope.paramMgrProcessors)\n"
        "        delete ModuleScope.paramMgrProcessors[this.instanceId];\n"
        "      this.destroyed = true;\n"
        "      this.port.close();\n"
        "    }\n"
        "  }\n"
        "  try {\n"
        "    registerProcessor(moduleId, ParamMgrProcessor);\n"
        "  } catch (error) {\n"
        "    console.warn(error);\n"
        "  }\n"
        "};\n"
        "var ParamMgrProcessor_default = processor;\n"
        "\n"
        "// src/sdk/src/WamParameterInfo.js\n"
        "var getWamParameterInfo = (moduleId) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  const normExp = (x, e) => e === 0 ? x : x ** 1.5 ** -e;\n"
        "  const denormExp = (x, e) => e === 0 ? x : x ** 1.5 ** e;\n"
        "  const normalize = (x, min, max, e = 0) => min === 0 && max === 1 ? normExp(x, e) : normExp((x - min) / (max - min) || 0, e);\n"
        "  const denormalize = (x, min, max, e = 0) => min === 0 && max === 1 ? denormExp(x, e) : denormExp(x, e) * (max - min) + min;\n"
        "  const inRange = (x, min, max) => x >= min && x <= max;\n"
        "  class WamParameterInfo2 {\n"
        "    /**\n"
        "     * @param {string} id\n"
        "     * @param {WamParameterConfiguration} [config]\n"
        "     */\n"
        "    constructor(id, config = {}) {\n"
        "      let {\n"
        "        type,\n"
        "        label,\n"
        "        defaultValue,\n"
        "        minValue,\n"
        "        maxValue,\n"
        "        discreteStep,\n"
        "        exponent,\n"
        "        choices,\n"
        "        units\n"
        "      } = config;\n"
        "      if (type === void 0)\n"
        "        type = \"float\";\n"
        "      if (label === void 0)\n"
        "        label = \"\";\n"
        "      if (defaultValue === void 0)\n"
        "        defaultValue = 0;\n"
        "      if (choices === void 0)\n"
        "        choices = [];\n"
        "      if (type === \"boolean\" || type === \"choice\") {\n"
        "        discreteStep = 1;\n"
        "        minValue = 0;\n"
        "        if (choices.length)\n"
        "          maxValue = choices.length - 1;\n"
        "        else\n"
        "          maxValue = 1;\n"
        "      } else {\n"
        "        if (minValue === void 0)\n"
        "          minValue = 0;\n"
        "        if (maxValue === void 0)\n"
        "          maxValue = 1;\n"
        "        if (discreteStep === void 0)\n"
        "          discreteStep = 0;\n"
        "        if (exponent === void 0)\n"
        "          exponent = 0;\n"
        "        if (units === void 0)\n"
        "          units = \"\";\n"
        "      }\n"
        "      const errBase = `Param config error | ${id}: `;\n"
        "      if (minValue >= maxValue)\n"
        "        throw Error(errBase.concat(\"minValue must be less than maxValue\"));\n"
        "      if (!inRange(defaultValue, minValue, maxValue))\n"
        "        throw Error(errBase.concat(\"defaultValue out of range\"));\n"
        "      if (discreteStep % 1 || discreteStep < 0) {\n"
        "        throw Error(errBase.concat(\"discreteStep must be a non-negative integer\"));\n"
        "      } else if (discreteStep > 0 && (minValue % 1 || maxValue % 1 || defaultValue % 1)) {\n"
        "        throw Error(errBase.concat(\"non-zero discreteStep requires integer minValue, maxValue, and defaultValue\"));\n"
        "      }\n"
        "      if (type === \"choice\" && !choices.length) {\n"
        "        throw Error(errBase.concat(\"choice type parameter requires list of strings in choices\"));\n"
        "      }\n"
        "      this.id = id;\n"
        "      this.label = label;\n"
        "      this.type = type;\n"
        "      this.defaultValue = defaultValue;\n"
        "      this.minValue = minValue;\n"
        "      this.maxValue = maxValue;\n"
        "      this.discreteStep = discreteStep;\n"
        "      this.exponent = exponent;\n"
        "      this.choices = choices;\n"
        "      this.units = units;\n"
        "    }\n"
        "    /**\n"
        "     * Convert a value from the parameter's denormalized range\n"
        "     * `[minValue, maxValue]` to normalized range `[0, 1]`.\n"
        "     * @param {number} value\n"
        "     */\n"
        "    normalize(value) {\n"
        "      return normalize(value, this.minValue, this.maxValue, this.exponent);\n"
        "    }\n"
        "    /**\n"
        "     * Convert a value from normalized range `[0, 1]` to the\n"
        "     * parameter's denormalized range `[minValue, maxValue]`.\n"
        "     * @param {number} valueNorm\n"
        "     */\n"
        "    denormalize(valueNorm) {\n"
        "      return denormalize(valueNorm, this.minValue, this.maxValue, this.exponent);\n"
        "    }\n"
        "    /**\n"
        "     * Get a human-readable string representing the given value,\n"
        "     * including units if applicable.\n"
        "     * @param {number} value\n"
        "     */\n"
        "    valueString(value) {\n"
        "      if (this.choices)\n"
        "        return this.choices[value];\n"
        "      if (this.units !== \"\")\n"
        "        return `${value} ${this.units}`;\n"
        "      return `${value}`;\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "    if (!ModuleScope.WamParameterInfo)\n"
        "      ModuleScope.WamParameterInfo = WamParameterInfo2;\n"
        "  }\n"
        "  return WamParameterInfo2;\n"
        "};\n"
        "var WamParameterInfo_default = getWamParameterInfo;\n"
        "\n"
        "// src/ParamConfigurator.js\n"
        "var WamParameterInfo = WamParameterInfo_default();\n"
        "var ParamMappingConfigurator = class {\n"
        "  /**\n"
        "   * @param {ParametersMappingConfiguratorOptions} [options = {}]\n"
        "   */\n"
        "  constructor(options = {}) {\n"
        "    /**\n"
        "     * @private\n"
        "     * @type {Record<string, WamParameterConfiguration>}\n"
        "     */\n"
        "    __publicField(this, \"_paramsConfig\");\n"
        "    /**\n"
        "     * @private\n"
        "     * @type {InternalParametersDescriptor}\n"
        "     */\n"
        "    __publicField(this, \"_internalParamsConfig\");\n"
        "    /**\n"
        "     * @private\n"
        "     * @type {ParametersMapping}\n"
        "     */\n"
        "    __publicField(this, \"_paramsMapping\", {});\n"
        "    const { paramsConfig, paramsMapping, internalParamsConfig } = options;\n"
        "    this._paramsConfig = paramsConfig;\n"
        "    this._paramsMapping = paramsMapping;\n"
        "    this._internalParamsConfig = internalParamsConfig;\n"
        "  }\n"
        "  /**\n"
        "   * Auto-completed `paramsConfig`:\n"
        "   *\n"
        "   * if no `paramsConfig` is defined while initializing, this will be be filled from the internalParamsConfig;\n"
        "   *\n"
        "   * if a parameter is not fully configured, the incompleted properties will have the same value as in the internalParamsConfig.\n"
        "   *\n"
        "   * @type {WamParameterInfoMap}\n"
        "   */\n"
        "  get paramsConfig() {\n"
        "    const { internalParamsConfig } = this;\n"
        "    return Object.entries(this._paramsConfig || internalParamsConfig).reduce((configs, [id, config]) => {\n"
        "      var _a, _b, _c, _d;\n"
        "      const internalParam = internalParamsConfig[id];\n"
        "      configs[id] = new WamParameterInfo(id, __spreadProps(__spreadValues({}, config), {\n"
        "        label: (_a = config.label) != null ? _a : id,\n"
        "        defaultValue: (_b = config.defaultValue) != null ? _b : internalParam == null ? void 0 : internalParam.defaultValue,\n"
        "        minValue: (_c = config.minValue) != null ? _c : internalParam == null ? void 0 : internalParam.minValue,\n"
        "        maxValue: (_d = config.maxValue) != null ? _d : internalParam == null ? void 0 : internalParam.maxValue\n"
        "      }));\n"
        "      return configs;\n"
        "    }, {});\n"
        "  }\n"
        "  /**\n"
        "   * Auto-completed configuration of the `internalParamsConfig`\n"
        "   *\n"
        "   * Internal Parameters Config contains all the automatable parameters' information.\n"
        "   *\n"
        "   * An automatable parameter could be a `WebAudio` `AudioParam`\n"
        "   * or a config with an `onChange` callback that will be called while the value has been changed.\n"
        "   *\n"
        "   * @type {InternalParametersDescriptor}\n"
        "   */\n"
        "  get internalParamsConfig() {\n"
        "    return Object.entries(this._internalParamsConfig || {}).reduce((configs, [name, config]) => {\n"
        "      if (config instanceof AudioParam)\n"
        "        configs[name] = config;\n"
        "      else {\n"
        "        const defaultConfig = {\n"
        "          minValue: 0,\n"
        "          maxValue: 1,\n"
        "          defaultValue: 0,\n"
        "          automationRate: 30\n"
        "        };\n"
        "        configs[name] = __spreadValues(__spreadValues({}, defaultConfig), config);\n"
        "      }\n"
        "      return configs;\n"
        "    }, {});\n"
        "  }\n"
        "  /**\n"
        "   * Auto-completed `paramsMapping`,\n"
        "   * the mapping can be omitted while initialized,\n"
        "   * but is useful when an exposed param (in the `paramsConfig`) should automate\n"
        "   * several internal params (in the `internalParamsConfig`) or has a different range there.\n"
        "   *\n"
        "   * If a parameter is present in both `paramsConfig` and `internalParamsConfig` (or the `paramsConfig` is not configured),\n"
        "   * a map of this parameter will be there automatically, if not declared explicitly.\n"
        "   *\n"
        "   * @type {ParametersMapping}\n"
        "   */\n"
        "  get paramsMapping() {\n"
        "    const declared = this._paramsMapping || {};\n"
        "    const externalParams = this.paramsConfig;\n"
        "    const internalParams = this.internalParamsConfig;\n"
        "    return Object.entries(externalParams).reduce((mapping, [name, { minValue, maxValue }]) => {\n"
        "      const sourceRange = [minValue, maxValue];\n"
        "      const defaultMapping = { sourceRange, targetRange: [...sourceRange] };\n"
        "      if (declared[name]) {\n"
        "        const declaredTargets = Object.entries(declared[name]).reduce((targets, [targetName, targetMapping]) => {\n"
        "          if (internalParams[targetName]) {\n"
        "            targets[targetName] = __spreadValues(__spreadValues({}, defaultMapping), targetMapping);\n"
        "          }\n"
        "          return targets;\n"
        "        }, {});\n"
        "        mapping[name] = declaredTargets;\n"
        "      } else if (internalParams[name]) {\n"
        "        mapping[name] = { [name]: __spreadValues({}, defaultMapping) };\n"
        "      }\n"
        "      return mapping;\n"
        "    }, {});\n"
        "  }\n"
        "};\n"
        "\n"
        "// src/MgrAudioParam.js\n"
        "var MgrAudioParam = class extends AudioParam {\n"
        "  constructor() {\n"
        "    super(...arguments);\n"
        "    /**\n"
        "     * @type {WamParameterInfo}\n"
        "     */\n"
        "    __publicField(this, \"_info\");\n"
        "  }\n"
        "  get exponent() {\n"
        "    return this.info.exponent;\n"
        "  }\n"
        "  get info() {\n"
        "    return this._info;\n"
        "  }\n"
        "  set info(info) {\n"
        "    this._info = info;\n"
        "  }\n"
        "  set normalizedValue(valueIn) {\n"
        "    this.value = this.info.denormalize(valueIn);\n"
        "  }\n"
        "  get normalizedValue() {\n"
        "    return this.info.normalize(this.value);\n"
        "  }\n"
        "  setValueAtTime(value, startTime) {\n"
        "    return super.setValueAtTime(value, startTime);\n"
        "  }\n"
        "  setNormalizedValueAtTime(valueIn, startTime) {\n"
        "    const value = this.info.denormalize(valueIn);\n"
        "    return this.setValueAtTime(value, startTime);\n"
        "  }\n"
        "  linearRampToValueAtTime(value, endTime) {\n"
        "    return super.linearRampToValueAtTime(value, endTime);\n"
        "  }\n"
        "  linearRampToNormalizedValueAtTime(valueIn, endTime) {\n"
        "    const value = this.info.denormalize(valueIn);\n"
        "    return this.linearRampToValueAtTime(value, endTime);\n"
        "  }\n"
        "  exponentialRampToValueAtTime(value, endTime) {\n"
        "    return super.exponentialRampToValueAtTime(value, endTime);\n"
        "  }\n"
        "  exponentialRampToNormalizedValueAtTime(valueIn, endTime) {\n"
        "    const value = this.info.denormalize(valueIn);\n"
        "    return this.exponentialRampToValueAtTime(value, endTime);\n"
        "  }\n"
        "  setTargetAtTime(target, startTime, timeConstant) {\n"
        "    return super.setTargetAtTime(target, startTime, timeConstant);\n"
        "  }\n"
        "  setNormalizedTargetAtTime(targetIn, startTime, timeConstant) {\n"
        "    const target = this.info.denormalize(targetIn);\n"
        "    return this.setTargetAtTime(target, startTime, timeConstant);\n"
        "  }\n"
        "  setValueCurveAtTime(values, startTime, duration) {\n"
        "    return super.setValueCurveAtTime(values, startTime, duration);\n"
        "  }\n"
        "  setNormalizedValueCurveAtTime(valuesIn, startTime, duration) {\n"
        "    const values = Array.from(valuesIn).map((v) => this.info.denormalize(v));\n"
        "    return this.setValueCurveAtTime(values, startTime, duration);\n"
        "  }\n"
        "  cancelScheduledParamValues(cancelTime) {\n"
        "    return super.cancelScheduledValues(cancelTime);\n"
        "  }\n"
        "  cancelAndHoldParamAtTime(cancelTime) {\n"
        "    return super.cancelAndHoldAtTime(cancelTime);\n"
        "  }\n"
        "};\n"
        "\n"
        "// src/ParamMgrNode.js\n"
        "var AudioWorkletNode = globalThis.AudioWorkletNode;\n"
        "var ParamMgrNode = class extends AudioWorkletNode {\n"
        "  /**\n"
        "      * @param {WebAudioModule} module\n"
        "      * @param {ParamMgrOptions} options\n"
        "      */\n"
        "  constructor(module, options) {\n"
        "    super(module.audioContext, module.moduleId, {\n"
        "      numberOfInputs: 0,\n"
        "      numberOfOutputs: 1 + options.processorOptions.internalParams.length,\n"
        "      parameterData: options.parameterData,\n"
        "      processorOptions: options.processorOptions\n"
        "    });\n"
        "    /**\n"
        "     * @param {string} name\n"
        "     */\n"
        "    __publicField(this, \"requestDispatchIParamChange\", (name) => {\n"
        "      const config = this.internalParamsConfig[name];\n"
        "      if (!(\"onChange\" in config))\n"
        "        return;\n"
        "      const { automationRate, onChange } = config;\n"
        "      if (typeof automationRate !== \"number\" || !automationRate)\n"
        "        return;\n"
        "      const interval = 1e3 / automationRate;\n"
        "      const i = this.internalParams.indexOf(name);\n"
        "      if (i === -1)\n"
        "        return;\n"
        "      if (i >= this.internalParams.length)\n"
        "        return;\n"
        "      if (typeof this.paramsUpdateCheckFnRef[i] === \"number\") {\n"
        "        window.clearTimeout(this.paramsUpdateCheckFnRef[i]);\n"
        "      }\n"
        "      this.paramsUpdateCheckFn[i] = () => {\n"
        "        const prev = this.$prevParamsBuffer[i];\n"
        "        const cur = this.$paramsBuffer[i];\n"
        "        if (cur !== prev) {\n"
        "          onChange(cur, prev);\n"
        "          this.$prevParamsBuffer[i] = cur;\n"
        "        }\n"
        "        this.paramsUpdateCheckFnRef[i] = window.setTimeout(this.paramsUpdateCheckFn[i], interval);\n"
        "      };\n"
        "      this.paramsUpdateCheckFn[i]();\n"
        "    });\n"
        "    const { processorOptions, internalParamsConfig } = options;\n"
        "    this.initialized = false;\n"
        "    this.module = module;\n"
        "    this.instanceId = options.processorOptions.instanceId;\n"
        "    this.groupId = options.processorOptions.groupId;\n"
        "    this.paramsConfig = processorOptions.paramsConfig;\n"
        "    this.internalParams = processorOptions.internalParams;\n"
        "    this.internalParamsConfig = internalParamsConfig;\n"
        "    this.$prevParamsBuffer = new Float32Array(this.internalParams.length);\n"
        "    this.paramsUpdateCheckFn = [];\n"
        "    this.paramsUpdateCheckFnRef = [];\n"
        "    this.messageRequestId = 0;\n"
        "    this.dummyGainNode = module.audioContext.createGain();\n"
        "    Object.entries(this.getParams()).forEach(([name, param]) => {\n"
        "      Object.setPrototypeOf(param, MgrAudioParam.prototype);\n"
        "      param._info = this.paramsConfig[name];\n"
        "    });\n"
        "    const resolves = {};\n"
        "    const rejects = {};\n"
        "    this.call = (call, ...args) => {\n"
        "      const id = this.messageRequestId;\n"
        "      this.messageRequestId += 1;\n"
        "      return new Promise((resolve, reject) => {\n"
        "        resolves[id] = resolve;\n"
        "        rejects[id] = reject;\n"
        "        this.port.postMessage({ id, call, args });\n"
        "      });\n"
        "    };\n"
        "    this.handleMessage = ({ data }) => {\n"
        "      var _a, _b;\n"
        "      const { id, call, args, value, error } = data;\n"
        "      if (call) {\n"
        "        const r = { id };\n"
        "        try {\n"
        "          r.value = this[call](...args);\n"
        "        } catch (e) {\n"
        "          r.error = e;\n"
        "        }\n"
        "        this.port.postMessage(r);\n"
        "      } else {\n"
        "        if (error)\n"
        "          (_a = rejects[id]) == null ? void 0 : _a.call(rejects, error);\n"
        "        else\n"
        "          (_b = resolves[id]) == null ? void 0 : _b.call(resolves, value);\n"
        "        delete resolves[id];\n"
        "        delete rejects[id];\n"
        "      }\n"
        "    };\n"
        "    this.port.start();\n"
        "    this.port.addEventListener(\"message\", this.handleMessage);\n"
        "  }\n"
        "  /**\n"
        "   * @returns {ReadonlyMap<string, MgrAudioParam>}\n"
        "   */\n"
        "  get parameters() {\n"
        "    return super.parameters;\n"
        "  }\n"
        "  get moduleId() {\n"
        "    return this.module.moduleId;\n"
        "  }\n"
        "  async initialize() {\n"
        "    const response = await this.call(\"getBuffer\");\n"
        "    const { lock, paramsBuffer } = response;\n"
        "    this.$lock = lock;\n"
        "    this.$paramsBuffer = paramsBuffer;\n"
        "    const offset = 1;\n"
        "    Object.entries(this.internalParamsConfig).forEach(([name, config], i) => {\n"
        "      if (this.context.state === \"suspended\")\n"
        "        this.$paramsBuffer[i] = config.defaultValue;\n"
        "      if (config instanceof AudioParam) {\n"
        "        try {\n"
        "          config.automationRate = \"a-rate\";\n"
        "        } catch (e) {\n"
        "        } finally {\n"
        "          config.value = Math.max(0, config.minValue);\n"
        "          this.connect(config, offset + i);\n"
        "          this.connect(this.dummyGainNode, offset + i, 0);\n"
        "        }\n"
        "      } else if (config instanceof AudioNode) {\n"
        "        this.connect(config, offset + i);\n"
        "      } else {\n"
        "        this.requestDispatchIParamChange(name);\n"
        "      }\n"
        "    });\n"
        "    this.connect(this.module.audioContext.destination, 0, 0);\n"
        "    this.initialized = true;\n"
        "    return this;\n"
        "  }\n"
        "  /**\n"
        "   * @param {ReturnType<ParamMgrCallToProcessor['getBuffer']>} buffer\n"
        "   */\n"
        "  setBuffer({ lock, paramsBuffer }) {\n"
        "    this.$lock = lock;\n"
        "    this.$paramsBuffer = paramsBuffer;\n"
        "  }\n"
        "  setParamsMapping(paramsMapping) {\n"
        "    return this.call(\"setParamsMapping\", paramsMapping);\n"
        "  }\n"
        "  getCompensationDelay() {\n"
        "    return this.call(\"getCompensationDelay\");\n"
        "  }\n"
        "  getParameterInfo(...parameterIdQuery) {\n"
        "    return this.call(\"getParameterInfo\", ...parameterIdQuery);\n"
        "  }\n"
        "  getParameterValues(normalized, ...parameterIdQuery) {\n"
        "    return this.call(\"getParameterValues\", normalized, ...parameterIdQuery);\n"
        "  }\n"
        "  /**\n"
        "   * @param {WamAutomationEvent} event\n"
        "   */\n"
        "  scheduleAutomation(event) {\n"
        "    const time = event.time || this.context.currentTime;\n"
        "    const { id, normalized, value } = event.data;\n"
        "    const audioParam = this.getParam(id);\n"
        "    if (!audioParam)\n"
        "      return;\n"
        "    if (audioParam.info.type === \"float\") {\n"
        "      if (normalized)\n"
        "        audioParam.linearRampToNormalizedValueAtTime(value, time);\n"
        "      else\n"
        "        audioParam.linearRampToValueAtTime(value, time);\n"
        "    } else {\n"
        "      if (normalized)\n"
        "        audioParam.setNormalizedValueAtTime(value, time);\n"
        "      else\n"
        "        audioParam.setValueAtTime(value, time);\n"
        "    }\n"
        "  }\n"
        "  /**\n"
        "   * @param {WamEvent[]} events\n"
        "   */\n"
        "  scheduleEvents(...events) {\n"
        "    events.forEach((event) => {\n"
        "      if (event.type === \"wam-automation\") {\n"
        "        this.scheduleAutomation(event);\n"
        "      }\n"
        "    });\n"
        "    this.call(\"scheduleEvents\", ...events);\n"
        "  }\n"
        "  /**\n"
        "   * @param {WamEvent[]} events\n"
        "   */\n"
        "  emitEvents(...events) {\n"
        "    this.call(\"emitEvents\", ...events);\n"
        "  }\n"
        "  clearEvents() {\n"
        "    this.call(\"clearEvents\");\n"
        "  }\n"
        "  /**\n"
        "   * @param {WamEvent} event\n"
        "   */\n"
        "  dispatchWamEvent(event) {\n"
        "    if (event.type === \"wam-automation\") {\n"
        "      this.scheduleAutomation(event);\n"
        "    } else {\n"
        "      this.dispatchEvent(new CustomEvent(event.type, { detail: event }));\n"
        "    }\n"
        "  }\n"
        "  /**\n"
        "   * @param {WamParameterValueMap} parameterValues\n"
        "   */\n"
        "  async setParameterValues(parameterValues) {\n"
        "    Object.keys(parameterValues).forEach((parameterId) => {\n"
        "      const parameterUpdate = parameterValues[parameterId];\n"
        "      const parameter = this.parameters.get(parameterId);\n"
        "      if (!parameter)\n"
        "        return;\n"
        "      if (!parameterUpdate.normalized)\n"
        "        parameter.value = parameterUpdate.value;\n"
        "      else\n"
        "        parameter.normalizedValue = parameterUpdate.value;\n"
        "    });\n"
        "  }\n"
        "  async getState() {\n"
        "    return this.getParamsValues();\n"
        "  }\n"
        "  async setState(state) {\n"
        "    this.setParamsValues(state);\n"
        "  }\n"
        "  convertTimeToFrame(time) {\n"
        "    return Math.round(time * this.context.sampleRate);\n"
        "  }\n"
        "  convertFrameToTime(frame) {\n"
        "    return frame / this.context.sampleRate;\n"
        "  }\n"
        "  /**\n"
        "   * @param {string} name\n"
        "   */\n"
        "  getIParamIndex(name) {\n"
        "    const i = this.internalParams.indexOf(name);\n"
        "    return i === -1 ? null : i;\n"
        "  }\n"
        "  /**\n"
        "   * @param {string} name\n"
        "   * @param {AudioParam | AudioNode} dest\n"
        "   * @param {number} index\n"
        "   */\n"
        "  connectIParam(name, dest, index) {\n"
        "    const offset = 1;\n"
        "    const i = this.getIParamIndex(name);\n"
        "    if (i !== null) {\n"
        "      if (dest instanceof AudioNode) {\n"
        "        if (typeof index === \"number\")\n"
        "          this.connect(dest, offset + i, index);\n"
        "        else\n"
        "          this.connect(dest, offset + i);\n"
        "      } else {\n"
        "        this.connect(dest, offset + i);\n"
        "      }\n"
        "    }\n"
        "  }\n"
        "  /**\n"
        "   * @param {string} name\n"
        "   * @param {AudioParam | AudioNode} dest\n"
        "   * @param {number} index\n"
        "   */\n"
        "  disconnectIParam(name, dest, index) {\n"
        "    const offset = 1;\n"
        "    const i = this.getIParamIndex(name);\n"
        "    if (i !== null) {\n"
        "      if (dest instanceof AudioNode) {\n"
        "        if (typeof index === \"number\")\n"
        "          this.disconnect(dest, offset + i, index);\n"
        "        else\n"
        "          this.disconnect(dest, offset + i);\n"
        "      } else {\n"
        "        this.disconnect(dest, offset + i);\n"
        "      }\n"
        "    }\n"
        "  }\n"
        "  getIParamValue(name) {\n"
        "    const i = this.getIParamIndex(name);\n"
        "    return i !== null ? this.$paramsBuffer[i] : null;\n"
        "  }\n"
        "  getIParamsValues() {\n"
        "    const values = {};\n"
        "    this.internalParams.forEach((name, i) => {\n"
        "      values[name] = this.$paramsBuffer[i];\n"
        "    });\n"
        "    return values;\n"
        "  }\n"
        "  getParam(name) {\n"
        "    return this.parameters.get(name) || null;\n"
        "  }\n"
        "  getParams() {\n"
        "    return Object.fromEntries(this.parameters);\n"
        "  }\n"
        "  getParamValue(name) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return null;\n"
        "    return param.value;\n"
        "  }\n"
        "  setParamValue(name, value) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return;\n"
        "    param.value = value;\n"
        "  }\n"
        "  getParamsValues() {\n"
        "    const values = {};\n"
        "    this.parameters.forEach((v, k) => {\n"
        "      values[k] = v.value;\n"
        "    });\n"
        "    return values;\n"
        "  }\n"
        "  /**\n"
        "   * @param {Record<string, number>} values\n"
        "   */\n"
        "  setParamsValues(values) {\n"
        "    if (!values)\n"
        "      return;\n"
        "    Object.entries(values).forEach(([k, v]) => {\n"
        "      this.setParamValue(k, v);\n"
        "    });\n"
        "  }\n"
        "  getNormalizedParamValue(name) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return null;\n"
        "    return param.normalizedValue;\n"
        "  }\n"
        "  setNormalizedParamValue(name, value) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return;\n"
        "    param.normalizedValue = value;\n"
        "  }\n"
        "  getNormalizedParamsValues() {\n"
        "    const values = {};\n"
        "    this.parameters.forEach((v, k) => {\n"
        "      values[k] = this.getNormalizedParamValue(k);\n"
        "    });\n"
        "    return values;\n"
        "  }\n"
        "  setNormalizedParamsValues(values) {\n"
        "    if (!values)\n"
        "      return;\n"
        "    Object.entries(values).forEach(([k, v]) => {\n"
        "      this.setNormalizedParamValue(k, v);\n"
        "    });\n"
        "  }\n"
        "  setParamValueAtTime(name, value, startTime) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return null;\n"
        "    return param.setValueAtTime(value, startTime);\n"
        "  }\n"
        "  setNormalizedParamValueAtTime(name, value, startTime) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return null;\n"
        "    return param.setNormalizedValueAtTime(value, startTime);\n"
        "  }\n"
        "  linearRampToParamValueAtTime(name, value, endTime) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return null;\n"
        "    return param.linearRampToValueAtTime(value, endTime);\n"
        "  }\n"
        "  linearRampToNormalizedParamValueAtTime(name, value, endTime) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return null;\n"
        "    return param.linearRampToNormalizedValueAtTime(value, endTime);\n"
        "  }\n"
        "  exponentialRampToParamValueAtTime(name, value, endTime) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return null;\n"
        "    return param.exponentialRampToValueAtTime(value, endTime);\n"
        "  }\n"
        "  exponentialRampToNormalizedParamValueAtTime(name, value, endTime) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return null;\n"
        "    return param.exponentialRampToNormalizedValueAtTime(value, endTime);\n"
        "  }\n"
        "  setParamTargetAtTime(name, target, startTime, timeConstant) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return null;\n"
        "    return param.setTargetAtTime(target, startTime, timeConstant);\n"
        "  }\n"
        "  setNormalizedParamTargetAtTime(name, target, startTime, timeConstant) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return null;\n"
        "    return param.setNormalizedTargetAtTime(target, startTime, timeConstant);\n"
        "  }\n"
        "  setParamValueCurveAtTime(name, values, startTime, duration) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return null;\n"
        "    return param.setValueCurveAtTime(values, startTime, duration);\n"
        "  }\n"
        "  setNormalizedParamValueCurveAtTime(name, values, startTime, duration) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return null;\n"
        "    return param.setNormalizedValueCurveAtTime(values, startTime, duration);\n"
        "  }\n"
        "  cancelScheduledParamValues(name, cancelTime) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return null;\n"
        "    return param.cancelScheduledValues(cancelTime);\n"
        "  }\n"
        "  cancelAndHoldParamAtTime(name, cancelTime) {\n"
        "    const param = this.parameters.get(name);\n"
        "    if (!param)\n"
        "      return null;\n"
        "    return param.cancelAndHoldAtTime(cancelTime);\n"
        "  }\n"
        "  /**\n"
        "   * @param {string} toId\n"
        "   * @param {number} [output]\n"
        "   */\n"
        "  connectEvents(toId, output) {\n"
        "    this.call(\"connectEvents\", toId, output);\n"
        "  }\n"
        "  /**\n"
        "   * @param {string} [toId]\n"
        "   * @param {number} [output]\n"
        "   */\n"
        "  disconnectEvents(toId, output) {\n"
        "    this.call(\"disconnectEvents\", toId, output);\n"
        "  }\n"
        "  async destroy() {\n"
        "    this.disconnect();\n"
        "    this.paramsUpdateCheckFnRef.forEach((ref) => {\n"
        "      if (typeof ref === \"number\")\n"
        "        window.clearTimeout(ref);\n"
        "    });\n"
        "    await this.call(\"destroy\");\n"
        "    this.port.close();\n"
        "  }\n"
        "};\n"
        "\n"
        "// src/ParamMgrFactory.js\n"
        "var ParamMgrFactory = class {\n"
        "  /**\n"
        "   * @param {WebAudioModule} module\n"
        "   * @param {ParametersMappingConfiguratorOptions} [optionsIn = {}]\n"
        "   */\n"
        "  static async create(module, optionsIn = {}) {\n"
        "    const { audioContext, moduleId } = module;\n"
        "    const instanceId = optionsIn.instanceId || module.instanceId;\n"
        "    const groupId = optionsIn.groupId || module.groupId;\n"
        "    const { paramsConfig, paramsMapping, internalParamsConfig } = new ParamMappingConfigurator(optionsIn);\n"
        "    const initialParamsValue = Object.entries(paramsConfig).reduce((currentParams, [name, { defaultValue }]) => {\n"
        "      currentParams[name] = defaultValue;\n"
        "      return currentParams;\n"
        "    }, {});\n"
        "    const serializableParamsConfig = Object.entries(paramsConfig).reduce((currentParams, [name, { id, label, type, defaultValue, minValue, maxValue, discreteStep, exponent, choices, units }]) => {\n"
        "      currentParams[name] = { id, label, type, defaultValue, minValue, maxValue, discreteStep, exponent, choices, units };\n"
        "      return currentParams;\n"
        "    }, {});\n"
        "    await addFunctionModule_default(audioContext.audioWorklet, ParamMgrProcessor_default, moduleId, serializableParamsConfig);\n"
        "    const options = {\n"
        "      internalParamsConfig,\n"
        "      parameterData: initialParamsValue,\n"
        "      processorOptions: {\n"
        "        paramsConfig,\n"
        "        paramsMapping,\n"
        "        internalParamsMinValues: Object.values(internalParamsConfig).map((config) => Math.max(0, (config == null ? void 0 : config.minValue) || 0)),\n"
        "        internalParams: Object.keys(internalParamsConfig),\n"
        "        groupId,\n"
        "        instanceId,\n"
        "        moduleId\n"
        "      }\n"
        "    };\n"
        "    const node = new ParamMgrNode(module, options);\n"
        "    await node.initialize();\n"
        "    return node;\n"
        "  }\n"
        "};\n"
        "export {\n"
        "  CompositeAudioNode,\n"
        "  ParamMgrFactory\n"
        "};\n"
        "//# sourceMappingURL=index.js.map\n";
    static constexpr const char* sdk_index_js = "// src/WebAudioModule.js\n"
        "var WebAudioModule = class {\n"
        "  static get isWebAudioModuleConstructor() {\n"
        "    return true;\n"
        "  }\n"
        "  static createInstance(groupId, audioContext, initialState) {\n"
        "    return new this(groupId, audioContext).initialize(initialState);\n"
        "  }\n"
        "  constructor(groupId, audioContext) {\n"
        "    this._groupId = groupId;\n"
        "    this._audioContext = audioContext;\n"
        "    this._initialized = false;\n"
        "    this._audioNode = void 0;\n"
        "    this._timestamp = performance.now();\n"
        "    this._guiModuleUrl = void 0;\n"
        "    this._descriptorUrl = \"./descriptor.json\";\n"
        "    this._descriptor = {\n"
        "      identifier: `com.webaudiomodule.default`,\n"
        "      name: `WebAudioModule_${this.constructor.name}`,\n"
        "      vendor: \"WebAudioModuleVendor\",\n"
        "      description: \"\",\n"
        "      version: \"0.0.0\",\n"
        "      apiVersion: \"2.0.0\",\n"
        "      thumbnail: \"\",\n"
        "      keywords: [],\n"
        "      isInstrument: false,\n"
        "      website: \"\",\n"
        "      hasAudioInput: true,\n"
        "      hasAudioOutput: true,\n"
        "      hasAutomationInput: true,\n"
        "      hasAutomationOutput: true,\n"
        "      hasMidiInput: true,\n"
        "      hasMidiOutput: true,\n"
        "      hasMpeInput: true,\n"
        "      hasMpeOutput: true,\n"
        "      hasOscInput: true,\n"
        "      hasOscOutput: true,\n"
        "      hasSysexInput: true,\n"
        "      hasSysexOutput: true\n"
        "    };\n"
        "  }\n"
        "  get isWebAudioModule() {\n"
        "    return true;\n"
        "  }\n"
        "  get groupId() {\n"
        "    return this._groupId;\n"
        "  }\n"
        "  get moduleId() {\n"
        "    return this.descriptor.identifier;\n"
        "  }\n"
        "  get instanceId() {\n"
        "    return this.moduleId + this._timestamp;\n"
        "  }\n"
        "  get descriptor() {\n"
        "    return this._descriptor;\n"
        "  }\n"
        "  get identifier() {\n"
        "    return this.descriptor.identifier;\n"
        "  }\n"
        "  get name() {\n"
        "    return this.descriptor.name;\n"
        "  }\n"
        "  get vendor() {\n"
        "    return this.descriptor.vendor;\n"
        "  }\n"
        "  get audioContext() {\n"
        "    return this._audioContext;\n"
        "  }\n"
        "  get audioNode() {\n"
        "    if (!this.initialized)\n"
        "      console.warn(\"WAM should be initialized before getting the audioNode\");\n"
        "    return this._audioNode;\n"
        "  }\n"
        "  set audioNode(node) {\n"
        "    this._audioNode = node;\n"
        "  }\n"
        "  get initialized() {\n"
        "    return this._initialized;\n"
        "  }\n"
        "  set initialized(value) {\n"
        "    this._initialized = value;\n"
        "  }\n"
        "  async createAudioNode(initialState) {\n"
        "    throw new TypeError(\"createAudioNode() not provided\");\n"
        "  }\n"
        "  async initialize(state) {\n"
        "    if (!this._audioNode)\n"
        "      this.audioNode = await this.createAudioNode();\n"
        "    this.initialized = true;\n"
        "    return this;\n"
        "  }\n"
        "  async _loadGui() {\n"
        "    const url = this._guiModuleUrl;\n"
        "    if (!url)\n"
        "      throw new TypeError(\"Gui module not found\");\n"
        "    return import(\n"
        "      /* webpackIgnore: true */\n"
        "      url\n"
        "    );\n"
        "  }\n"
        "  async _loadDescriptor() {\n"
        "    const url = this._descriptorUrl;\n"
        "    if (!url)\n"
        "      throw new TypeError(\"Descriptor not found\");\n"
        "    const response = await fetch(url);\n"
        "    const descriptor = await response.json();\n"
        "    Object.assign(this._descriptor, descriptor);\n"
        "    return this._descriptor;\n"
        "  }\n"
        "  async createGui() {\n"
        "    if (!this.initialized)\n"
        "      console.warn(\"Plugin should be initialized before getting the gui\");\n"
        "    if (!this._guiModuleUrl)\n"
        "      return void 0;\n"
        "    const { createElement } = await this._loadGui();\n"
        "    return createElement(this);\n"
        "  }\n"
        "  destroyGui() {\n"
        "  }\n"
        "};\n"
        "var WebAudioModule_default = WebAudioModule;\n"
        "\n"
        "// src/RingBuffer.js\n"
        "var getRingBuffer = (moduleId) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  class RingBuffer2 {\n"
        "    static getStorageForCapacity(capacity, Type) {\n"
        "      if (!Type.BYTES_PER_ELEMENT) {\n"
        "        throw new Error(\"Pass in a ArrayBuffer subclass\");\n"
        "      }\n"
        "      const bytes = 8 + (capacity + 1) * Type.BYTES_PER_ELEMENT;\n"
        "      return new SharedArrayBuffer(bytes);\n"
        "    }\n"
        "    constructor(sab, Type) {\n"
        "      if (!Type.BYTES_PER_ELEMENT) {\n"
        "        throw new Error(\"Pass a concrete typed array class as second argument\");\n"
        "      }\n"
        "      this._Type = Type;\n"
        "      this._capacity = (sab.byteLength - 8) / Type.BYTES_PER_ELEMENT;\n"
        "      this.buf = sab;\n"
        "      this.write_ptr = new Uint32Array(this.buf, 0, 1);\n"
        "      this.read_ptr = new Uint32Array(this.buf, 4, 1);\n"
        "      this.storage = new Type(this.buf, 8, this._capacity);\n"
        "    }\n"
        "    get type() {\n"
        "      return this._Type.name;\n"
        "    }\n"
        "    push(elements) {\n"
        "      const rd = Atomics.load(this.read_ptr, 0);\n"
        "      const wr = Atomics.load(this.write_ptr, 0);\n"
        "      if ((wr + 1) % this._storageCapacity() === rd) {\n"
        "        return 0;\n"
        "      }\n"
        "      const toWrite = Math.min(this._availableWrite(rd, wr), elements.length);\n"
        "      const firstPart = Math.min(this._storageCapacity() - wr, toWrite);\n"
        "      const secondPart = toWrite - firstPart;\n"
        "      this._copy(elements, 0, this.storage, wr, firstPart);\n"
        "      this._copy(elements, firstPart, this.storage, 0, secondPart);\n"
        "      Atomics.store(this.write_ptr, 0, (wr + toWrite) % this._storageCapacity());\n"
        "      return toWrite;\n"
        "    }\n"
        "    pop(elements) {\n"
        "      const rd = Atomics.load(this.read_ptr, 0);\n"
        "      const wr = Atomics.load(this.write_ptr, 0);\n"
        "      if (wr === rd) {\n"
        "        return 0;\n"
        "      }\n"
        "      const isArray = !Number.isInteger(elements);\n"
        "      const toRead = Math.min(this._availableRead(rd, wr), isArray ? elements.length : elements);\n"
        "      if (isArray) {\n"
        "        const firstPart = Math.min(this._storageCapacity() - rd, toRead);\n"
        "        const secondPart = toRead - firstPart;\n"
        "        this._copy(this.storage, rd, elements, 0, firstPart);\n"
        "        this._copy(this.storage, 0, elements, firstPart, secondPart);\n"
        "      }\n"
        "      Atomics.store(this.read_ptr, 0, (rd + toRead) % this._storageCapacity());\n"
        "      return toRead;\n"
        "    }\n"
        "    get empty() {\n"
        "      const rd = Atomics.load(this.read_ptr, 0);\n"
        "      const wr = Atomics.load(this.write_ptr, 0);\n"
        "      return wr === rd;\n"
        "    }\n"
        "    get full() {\n"
        "      const rd = Atomics.load(this.read_ptr, 0);\n"
        "      const wr = Atomics.load(this.write_ptr, 0);\n"
        "      return (wr + 1) % this._capacity !== rd;\n"
        "    }\n"
        "    get capacity() {\n"
        "      return this._capacity - 1;\n"
        "    }\n"
        "    get availableRead() {\n"
        "      const rd = Atomics.load(this.read_ptr, 0);\n"
        "      const wr = Atomics.load(this.write_ptr, 0);\n"
        "      return this._availableRead(rd, wr);\n"
        "    }\n"
        "    get availableWrite() {\n"
        "      const rd = Atomics.load(this.read_ptr, 0);\n"
        "      const wr = Atomics.load(this.write_ptr, 0);\n"
        "      return this._availableWrite(rd, wr);\n"
        "    }\n"
        "    _availableRead(rd, wr) {\n"
        "      if (wr > rd) {\n"
        "        return wr - rd;\n"
        "      }\n"
        "      return wr + this._storageCapacity() - rd;\n"
        "    }\n"
        "    _availableWrite(rd, wr) {\n"
        "      let rv = rd - wr - 1;\n"
        "      if (wr >= rd) {\n"
        "        rv += this._storageCapacity();\n"
        "      }\n"
        "      return rv;\n"
        "    }\n"
        "    _storageCapacity() {\n"
        "      return this._capacity;\n"
        "    }\n"
        "    _copy(input, offsetInput, output, offsetOutput, size) {\n"
        "      for (let i = 0; i < size; i++) {\n"
        "        output[offsetOutput + i] = input[offsetInput + i];\n"
        "      }\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "    if (!ModuleScope.RingBuffer)\n"
        "      ModuleScope.RingBuffer = RingBuffer2;\n"
        "  }\n"
        "  return RingBuffer2;\n"
        "};\n"
        "var RingBuffer_default = getRingBuffer;\n"
        "\n"
        "// src/WamArrayRingBuffer.js\n"
        "var getWamArrayRingBuffer = (moduleId) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  class WamArrayRingBuffer {\n"
        "    static DefaultArrayCapacity = 2;\n"
        "    static getStorageForEventCapacity(RingBuffer2, arrayLength, arrayType, maxArrayCapacity = void 0) {\n"
        "      if (maxArrayCapacity === void 0)\n"
        "        maxArrayCapacity = WamArrayRingBuffer.DefaultArrayCapacity;\n"
        "      else\n"
        "        maxArrayCapacity = Math.max(maxArrayCapacity, WamArrayRingBuffer.DefaultArrayCapacity);\n"
        "      if (!arrayType.BYTES_PER_ELEMENT) {\n"
        "        throw new Error(\"Pass in a ArrayBuffer subclass\");\n"
        "      }\n"
        "      const capacity = arrayLength * maxArrayCapacity;\n"
        "      return RingBuffer2.getStorageForCapacity(capacity, arrayType);\n"
        "    }\n"
        "    constructor(RingBuffer2, sab, arrayLength, arrayType, maxArrayCapacity = void 0) {\n"
        "      if (!arrayType.BYTES_PER_ELEMENT) {\n"
        "        throw new Error(\"Pass in a ArrayBuffer subclass\");\n"
        "      }\n"
        "      this._arrayLength = arrayLength;\n"
        "      this._arrayType = arrayType;\n"
        "      this._arrayElementSizeBytes = arrayType.BYTES_PER_ELEMENT;\n"
        "      this._arraySizeBytes = this._arrayLength * this._arrayElementSizeBytes;\n"
        "      this._sab = sab;\n"
        "      if (maxArrayCapacity === void 0)\n"
        "        maxArrayCapacity = WamArrayRingBuffer.DefaultArrayCapacity;\n"
        "      else\n"
        "        maxArrayCapacity = Math.max(maxArrayCapacity, WamArrayRingBuffer.DefaultArrayCapacity);\n"
        "      this._arrayArray = new arrayType(this._arrayLength);\n"
        "      this._rb = new RingBuffer2(this._sab, arrayType);\n"
        "    }\n"
        "    write(array) {\n"
        "      if (array.length !== this._arrayLength)\n"
        "        return false;\n"
        "      const elementsAvailable = this._rb.availableWrite;\n"
        "      if (elementsAvailable < this._arrayLength)\n"
        "        return false;\n"
        "      let success = true;\n"
        "      const elementsWritten = this._rb.push(array);\n"
        "      if (elementsWritten != this._arrayLength)\n"
        "        success = false;\n"
        "      return success;\n"
        "    }\n"
        "    read(array, newest) {\n"
        "      if (array.length !== this._arrayLength)\n"
        "        return false;\n"
        "      const elementsAvailable = this._rb.availableRead;\n"
        "      if (elementsAvailable < this._arrayLength)\n"
        "        return false;\n"
        "      if (newest && elementsAvailable > this._arrayLength)\n"
        "        this._rb.pop(elementsAvailable - this._arrayLength);\n"
        "      let success = false;\n"
        "      const elementsRead = this._rb.pop(array);\n"
        "      if (elementsRead === this._arrayLength)\n"
        "        success = true;\n"
        "      return success;\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "    if (!ModuleScope.WamArrayRingBuffer)\n"
        "      ModuleScope.WamArrayRingBuffer = WamArrayRingBuffer;\n"
        "  }\n"
        "  return WamArrayRingBuffer;\n"
        "};\n"
        "var WamArrayRingBuffer_default = getWamArrayRingBuffer;\n"
        "\n"
        "// src/WamEnv.js\n"
        "var initializeWamEnv = (apiVersion) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor && audioWorkletGlobalScope.webAudioModules)\n"
        "    return;\n"
        "  const moduleScopes = /* @__PURE__ */ new Map();\n"
        "  const groups = /* @__PURE__ */ new Map();\n"
        "  class WamEnv {\n"
        "    constructor() {\n"
        "    }\n"
        "    get apiVersion() {\n"
        "      return apiVersion;\n"
        "    }\n"
        "    getModuleScope(moduleId) {\n"
        "      if (!moduleScopes.has(moduleId))\n"
        "        moduleScopes.set(moduleId, {});\n"
        "      return moduleScopes.get(moduleId);\n"
        "    }\n"
        "    getGroup(groupId, groupKey) {\n"
        "      const group = groups.get(groupId);\n"
        "      if (group.validate(groupKey))\n"
        "        return group;\n"
        "      else\n"
        "        throw \"Invalid key\";\n"
        "    }\n"
        "    addGroup(group) {\n"
        "      if (!groups.has(group.groupId))\n"
        "        groups.set(group.groupId, group);\n"
        "    }\n"
        "    removeGroup(group) {\n"
        "      groups.delete(group.groupId);\n"
        "    }\n"
        "    addWam(wam) {\n"
        "      const group = groups.get(wam.groupId);\n"
        "      group.addWam(wam);\n"
        "    }\n"
        "    removeWam(wam) {\n"
        "      const group = groups.get(wam.groupId);\n"
        "      group.removeWam(wam);\n"
        "    }\n"
        "    connectEvents(groupId, fromId, toId, output = 0) {\n"
        "      const group = groups.get(groupId);\n"
        "      group.connectEvents(fromId, toId, output);\n"
        "    }\n"
        "    disconnectEvents(groupId, fromId, toId, output) {\n"
        "      const group = groups.get(groupId);\n"
        "      group.disconnectEvents(fromId, toId, output);\n"
        "    }\n"
        "    emitEvents(from, ...events) {\n"
        "      const group = groups.get(from.groupId);\n"
        "      group.emitEvents(from, ...events);\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    if (!audioWorkletGlobalScope.webAudioModules)\n"
        "      audioWorkletGlobalScope.webAudioModules = new WamEnv();\n"
        "  }\n"
        "};\n"
        "var WamEnv_default = initializeWamEnv;\n"
        "\n"
        "// src/WamGroup.js\n"
        "var initializeWamGroup = (groupId, groupKey) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  class WamGroup {\n"
        "    constructor(groupId2, groupKey2) {\n"
        "      this._groupId = groupId2;\n"
        "      this._validate = (key) => {\n"
        "        return key == groupKey2;\n"
        "      };\n"
        "      this._processors = /* @__PURE__ */ new Map();\n"
        "      this._eventGraph = /* @__PURE__ */ new Map();\n"
        "    }\n"
        "    get groupId() {\n"
        "      return this._groupId;\n"
        "    }\n"
        "    get processors() {\n"
        "      return this._processors;\n"
        "    }\n"
        "    get eventGraph() {\n"
        "      return this._eventGraph;\n"
        "    }\n"
        "    validate(groupKey2) {\n"
        "      return this._validate(groupKey2);\n"
        "    }\n"
        "    addWam(wam) {\n"
        "      this._processors.set(wam.instanceId, wam);\n"
        "    }\n"
        "    removeWam(wam) {\n"
        "      if (this._eventGraph.has(wam))\n"
        "        this._eventGraph.delete(wam);\n"
        "      this._eventGraph.forEach((outputMap) => {\n"
        "        outputMap.forEach((set) => {\n"
        "          if (set && set.has(wam))\n"
        "            set.delete(wam);\n"
        "        });\n"
        "      });\n"
        "      this._processors.delete(wam.instanceId);\n"
        "    }\n"
        "    connectEvents(fromId, toId, output) {\n"
        "      const from = this._processors.get(fromId);\n"
        "      const to = this._processors.get(toId);\n"
        "      let outputMap;\n"
        "      if (this._eventGraph.has(from)) {\n"
        "        outputMap = this._eventGraph.get(from);\n"
        "      } else {\n"
        "        outputMap = [];\n"
        "        this._eventGraph.set(from, outputMap);\n"
        "      }\n"
        "      if (outputMap[output]) {\n"
        "        outputMap[output].add(to);\n"
        "      } else {\n"
        "        const set = /* @__PURE__ */ new Set();\n"
        "        set.add(to);\n"
        "        outputMap[output] = set;\n"
        "      }\n"
        "    }\n"
        "    disconnectEvents(fromId, toId, output) {\n"
        "      const from = this._processors.get(fromId);\n"
        "      if (!this._eventGraph.has(from))\n"
        "        return;\n"
        "      const outputMap = this._eventGraph.get(from);\n"
        "      if (typeof toId === \"undefined\") {\n"
        "        outputMap.forEach((set) => {\n"
        "          if (set)\n"
        "            set.clear();\n"
        "        });\n"
        "        return;\n"
        "      }\n"
        "      const to = this._processors.get(toId);\n"
        "      if (typeof output === \"undefined\") {\n"
        "        outputMap.forEach((set) => {\n"
        "          if (set)\n"
        "            set.delete(to);\n"
        "        });\n"
        "        return;\n"
        "      }\n"
        "      if (!outputMap[output])\n"
        "        return;\n"
        "      outputMap[output].delete(to);\n"
        "    }\n"
        "    emitEvents(from, ...events) {\n"
        "      if (!this._eventGraph.has(from))\n"
        "        return;\n"
        "      const downstream = this._eventGraph.get(from);\n"
        "      downstream.forEach((set) => {\n"
        "        if (set)\n"
        "          set.forEach((wam) => wam.scheduleEvents(...events));\n"
        "      });\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    audioWorkletGlobalScope.webAudioModules.addGroup(new WamGroup(groupId, groupKey));\n"
        "  }\n"
        "};\n"
        "var WamGroup_default = initializeWamGroup;\n"
        "\n"
        "// src/WamEventRingBuffer.js\n"
        "var getWamEventRingBuffer = (moduleId) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  class WamEventRingBuffer2 {\n"
        "    static DefaultExtraBytesPerEvent = 64;\n"
        "    static WamEventBaseBytes = 4 + 1 + 8;\n"
        "    static WamAutomationEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 2 + 8 + 1;\n"
        "    static WamTransportEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 4 + 8 + 8 + 1 + 1 + 1;\n"
        "    static WamMidiEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 1 + 1 + 1;\n"
        "    static WamBinaryEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 4;\n"
        "    static getStorageForEventCapacity(RingBuffer2, eventCapacity, maxBytesPerEvent = void 0) {\n"
        "      if (maxBytesPerEvent === void 0)\n"
        "        maxBytesPerEvent = WamEventRingBuffer2.DefaultExtraBytesPerEvent;\n"
        "      else\n"
        "        maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer2.DefaultExtraBytesPerEvent);\n"
        "      const capacity = (Math.max(WamEventRingBuffer2.WamAutomationEventBytes, WamEventRingBuffer2.WamTransportEventBytes, WamEventRingBuffer2.WamMidiEventBytes, WamEventRingBuffer2.WamBinaryEventBytes) + maxBytesPerEvent) * eventCapacity;\n"
        "      return RingBuffer2.getStorageForCapacity(capacity, Uint8Array);\n"
        "    }\n"
        "    constructor(RingBuffer2, sab, parameterIds, maxBytesPerEvent = void 0) {\n"
        "      this._eventSizeBytes = {};\n"
        "      this._encodeEventType = {};\n"
        "      this._decodeEventType = {};\n"
        "      const wamEventTypes = [\"wam-automation\", \"wam-transport\", \"wam-midi\", \"wam-sysex\", \"wam-mpe\", \"wam-osc\", \"wam-info\"];\n"
        "      wamEventTypes.forEach((type, encodedType) => {\n"
        "        let byteSize = 0;\n"
        "        switch (type) {\n"
        "          case \"wam-automation\":\n"
        "            byteSize = WamEventRingBuffer2.WamAutomationEventBytes;\n"
        "            break;\n"
        "          case \"wam-transport\":\n"
        "            byteSize = WamEventRingBuffer2.WamTransportEventBytes;\n"
        "            break;\n"
        "          case \"wam-mpe\":\n"
        "          case \"wam-midi\":\n"
        "            byteSize = WamEventRingBuffer2.WamMidiEventBytes;\n"
        "            break;\n"
        "          case \"wam-osc\":\n"
        "          case \"wam-sysex\":\n"
        "          case \"wam-info\":\n"
        "            byteSize = WamEventRingBuffer2.WamBinaryEventBytes;\n"
        "            break;\n"
        "          default:\n"
        "            break;\n"
        "        }\n"
        "        this._eventSizeBytes[type] = byteSize;\n"
        "        this._encodeEventType[type] = encodedType;\n"
        "        this._decodeEventType[encodedType] = type;\n"
        "      });\n"
        "      this._parameterCode = 0;\n"
        "      this._parameterCodes = {};\n"
        "      this._encodeParameterId = {};\n"
        "      this._decodeParameterId = {};\n"
        "      this.setParameterIds(parameterIds);\n"
        "      this._sab = sab;\n"
        "      if (maxBytesPerEvent === void 0)\n"
        "        maxBytesPerEvent = WamEventRingBuffer2.DefaultExtraBytesPerEvent;\n"
        "      else\n"
        "        maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer2.DefaultExtraBytesPerEvent);\n"
        "      this._eventBytesAvailable = Math.max(WamEventRingBuffer2.WamAutomationEventBytes, WamEventRingBuffer2.WamTransportEventBytes, WamEventRingBuffer2.WamMidiEventBytes, WamEventRingBuffer2.WamBinaryEventBytes) + maxBytesPerEvent;\n"
        "      this._eventBytes = new ArrayBuffer(this._eventBytesAvailable);\n"
        "      this._eventBytesView = new DataView(this._eventBytes);\n"
        "      this._rb = new RingBuffer2(this._sab, Uint8Array);\n"
        "      this._eventSizeArray = new Uint8Array(this._eventBytes, 0, 4);\n"
        "      this._eventSizeView = new DataView(this._eventBytes, 0, 4);\n"
        "    }\n"
        "    _writeHeader(byteSize, type, time) {\n"
        "      let byteOffset = 0;\n"
        "      this._eventBytesView.setUint32(byteOffset, byteSize);\n"
        "      byteOffset += 4;\n"
        "      this._eventBytesView.setUint8(byteOffset, this._encodeEventType[type]);\n"
        "      byteOffset += 1;\n"
        "      this._eventBytesView.setFloat64(byteOffset, Number.isFinite(time) ? time : -1);\n"
        "      byteOffset += 8;\n"
        "      return byteOffset;\n"
        "    }\n"
        "    _encode(event) {\n"
        "      let byteOffset = 0;\n"
        "      const { type, time } = event;\n"
        "      switch (event.type) {\n"
        "        case \"wam-automation\":\n"
        "          {\n"
        "            if (!(event.data.id in this._encodeParameterId))\n"
        "              break;\n"
        "            const byteSize = this._eventSizeBytes[type];\n"
        "            byteOffset = this._writeHeader(byteSize, type, time);\n"
        "            const { data } = event;\n"
        "            const encodedParameterId = this._encodeParameterId[data.id];\n"
        "            const { value, normalized } = data;\n"
        "            this._eventBytesView.setUint16(byteOffset, encodedParameterId);\n"
        "            byteOffset += 2;\n"
        "            this._eventBytesView.setFloat64(byteOffset, value);\n"
        "            byteOffset += 8;\n"
        "            this._eventBytesView.setUint8(byteOffset, normalized ? 1 : 0);\n"
        "            byteOffset += 1;\n"
        "          }\n"
        "          break;\n"
        "        case \"wam-transport\":\n"
        "          {\n"
        "            const byteSize = this._eventSizeBytes[type];\n"
        "            byteOffset = this._writeHeader(byteSize, type, time);\n"
        "            const { data } = event;\n"
        "            const {\n"
        "              currentBar,\n"
        "              currentBarStarted,\n"
        "              tempo,\n"
        "              timeSigNumerator,\n"
        "              timeSigDenominator,\n"
        "              playing\n"
        "            } = data;\n"
        "            this._eventBytesView.setUint32(byteOffset, currentBar);\n"
        "            byteOffset += 4;\n"
        "            this._eventBytesView.setFloat64(byteOffset, currentBarStarted);\n"
        "            byteOffset += 8;\n"
        "            this._eventBytesView.setFloat64(byteOffset, tempo);\n"
        "            byteOffset += 8;\n"
        "            this._eventBytesView.setUint8(byteOffset, timeSigNumerator);\n"
        "            byteOffset += 1;\n"
        "            this._eventBytesView.setUint8(byteOffset, timeSigDenominator);\n"
        "            byteOffset += 1;\n"
        "            this._eventBytesView.setUint8(byteOffset, playing ? 1 : 0);\n"
        "            byteOffset += 1;\n"
        "          }\n"
        "          break;\n"
        "        case \"wam-mpe\":\n"
        "        case \"wam-midi\":\n"
        "          {\n"
        "            const byteSize = this._eventSizeBytes[type];\n"
        "            byteOffset = this._writeHeader(byteSize, type, time);\n"
        "            const { data } = event;\n"
        "            const { bytes } = data;\n"
        "            let b = 0;\n"
        "            while (b < 3) {\n"
        "              this._eventBytesView.setUint8(byteOffset, bytes[b]);\n"
        "              byteOffset += 1;\n"
        "              b++;\n"
        "            }\n"
        "          }\n"
        "          break;\n"
        "        case \"wam-osc\":\n"
        "        case \"wam-sysex\":\n"
        "        case \"wam-info\":\n"
        "          {\n"
        "            let bytes = null;\n"
        "            if (event.type === \"wam-info\") {\n"
        "              const { data } = event;\n"
        "              bytes = new TextEncoder().encode(data.instanceId);\n"
        "            } else {\n"
        "              const { data } = event;\n"
        "              bytes = data.bytes;\n"
        "            }\n"
        "            const numBytes = bytes.length;\n"
        "            const byteSize = this._eventSizeBytes[type];\n"
        "            byteOffset = this._writeHeader(byteSize + numBytes, type, time);\n"
        "            this._eventBytesView.setUint32(byteOffset, numBytes);\n"
        "            byteOffset += 4;\n"
        "            const bytesRequired = byteOffset + numBytes;\n"
        "            if (bytesRequired > this._eventBytesAvailable)\n"
        "              console.error(`Event requires ${bytesRequired} bytes but only ${this._eventBytesAvailable} have been allocated!`);\n"
        "            const buffer = new Uint8Array(this._eventBytes, byteOffset, numBytes);\n"
        "            buffer.set(bytes);\n"
        "            byteOffset += numBytes;\n"
        "          }\n"
        "          break;\n"
        "        default:\n"
        "          break;\n"
        "      }\n"
        "      return new Uint8Array(this._eventBytes, 0, byteOffset);\n"
        "    }\n"
        "    _decode() {\n"
        "      let byteOffset = 0;\n"
        "      const type = this._decodeEventType[this._eventBytesView.getUint8(byteOffset)];\n"
        "      byteOffset += 1;\n"
        "      let time = this._eventBytesView.getFloat64(byteOffset);\n"
        "      if (time === -1)\n"
        "        time = void 0;\n"
        "      byteOffset += 8;\n"
        "      switch (type) {\n"
        "        case \"wam-automation\": {\n"
        "          const encodedParameterId = this._eventBytesView.getUint16(byteOffset);\n"
        "          byteOffset += 2;\n"
        "          const value = this._eventBytesView.getFloat64(byteOffset);\n"
        "          byteOffset += 8;\n"
        "          const normalized = !!this._eventBytesView.getUint8(byteOffset);\n"
        "          byteOffset += 1;\n"
        "          if (!(encodedParameterId in this._decodeParameterId))\n"
        "            break;\n"
        "          const id = this._decodeParameterId[encodedParameterId];\n"
        "          const event = {\n"
        "            type,\n"
        "            time,\n"
        "            data: {\n"
        "              id,\n"
        "              value,\n"
        "              normalized\n"
        "            }\n"
        "          };\n"
        "          return event;\n"
        "        }\n"
        "        case \"wam-transport\": {\n"
        "          const currentBar = this._eventBytesView.getUint32(byteOffset);\n"
        "          byteOffset += 4;\n"
        "          const currentBarStarted = this._eventBytesView.getFloat64(byteOffset);\n"
        "          byteOffset += 8;\n"
        "          const tempo = this._eventBytesView.getFloat64(byteOffset);\n"
        "          byteOffset += 8;\n"
        "          const timeSigNumerator = this._eventBytesView.getUint8(byteOffset);\n"
        "          byteOffset += 1;\n"
        "          const timeSigDenominator = this._eventBytesView.getUint8(byteOffset);\n"
        "          byteOffset += 1;\n"
        "          const playing = this._eventBytesView.getUint8(byteOffset) == 1;\n"
        "          byteOffset += 1;\n"
        "          const event = {\n"
        "            type,\n"
        "            time,\n"
        "            data: {\n"
        "              currentBar,\n"
        "              currentBarStarted,\n"
        "              tempo,\n"
        "              timeSigNumerator,\n"
        "              timeSigDenominator,\n"
        "              playing\n"
        "            }\n"
        "          };\n"
        "          return event;\n"
        "        }\n"
        "        case \"wam-mpe\":\n"
        "        case \"wam-midi\": {\n"
        "          const bytes = [0, 0, 0];\n"
        "          let b = 0;\n"
        "          while (b < 3) {\n"
        "            bytes[b] = this._eventBytesView.getUint8(byteOffset);\n"
        "            byteOffset += 1;\n"
        "            b++;\n"
        "          }\n"
        "          const event = {\n"
        "            type,\n"
        "            time,\n"
        "            data: { bytes }\n"
        "          };\n"
        "          return event;\n"
        "        }\n"
        "        case \"wam-osc\":\n"
        "        case \"wam-sysex\":\n"
        "        case \"wam-info\": {\n"
        "          const numBytes = this._eventBytesView.getUint32(byteOffset);\n"
        "          byteOffset += 4;\n"
        "          const bytes = new Uint8Array(numBytes);\n"
        "          bytes.set(new Uint8Array(this._eventBytes, byteOffset, numBytes));\n"
        "          byteOffset += numBytes;\n"
        "          if (type === \"wam-info\") {\n"
        "            const instanceId = new TextDecoder().decode(bytes);\n"
        "            const data = { instanceId };\n"
        "            return { type, time, data };\n"
        "          } else {\n"
        "            const data = { bytes };\n"
        "            return { type, time, data };\n"
        "          }\n"
        "        }\n"
        "        default:\n"
        "          break;\n"
        "      }\n"
        "      return false;\n"
        "    }\n"
        "    write(...events) {\n"
        "      const numEvents = events.length;\n"
        "      let bytesAvailable = this._rb.availableWrite;\n"
        "      let numSkipped = 0;\n"
        "      let i = 0;\n"
        "      while (i < numEvents) {\n"
        "        const event = events[i];\n"
        "        const bytes = this._encode(event);\n"
        "        const eventSizeBytes = bytes.byteLength;\n"
        "        let bytesWritten = 0;\n"
        "        if (bytesAvailable >= eventSizeBytes) {\n"
        "          if (eventSizeBytes === 0)\n"
        "            numSkipped++;\n"
        "          else\n"
        "            bytesWritten = this._rb.push(bytes);\n"
        "        } else\n"
        "          break;\n"
        "        bytesAvailable -= bytesWritten;\n"
        "        i++;\n"
        "      }\n"
        "      return i - numSkipped;\n"
        "    }\n"
        "    read() {\n"
        "      if (this._rb.empty)\n"
        "        return [];\n"
        "      const events = [];\n"
        "      let bytesAvailable = this._rb.availableRead;\n"
        "      let bytesRead = 0;\n"
        "      while (bytesAvailable > 0) {\n"
        "        bytesRead = this._rb.pop(this._eventSizeArray);\n"
        "        bytesAvailable -= bytesRead;\n"
        "        const eventSizeBytes = this._eventSizeView.getUint32(0);\n"
        "        const eventBytes = new Uint8Array(this._eventBytes, 0, eventSizeBytes - 4);\n"
        "        bytesRead = this._rb.pop(eventBytes);\n"
        "        bytesAvailable -= bytesRead;\n"
        "        const decodedEvent = this._decode();\n"
        "        if (decodedEvent)\n"
        "          events.push(decodedEvent);\n"
        "      }\n"
        "      return events;\n"
        "    }\n"
        "    setParameterIds(parameterIds) {\n"
        "      this._encodeParameterId = {};\n"
        "      this._decodeParameterId = {};\n"
        "      parameterIds.forEach((parameterId) => {\n"
        "        let parameterCode = -1;\n"
        "        if (parameterId in this._parameterCodes)\n"
        "          parameterCode = this._parameterCodes[parameterId];\n"
        "        else {\n"
        "          parameterCode = this._generateParameterCode();\n"
        "          this._parameterCodes[parameterId] = parameterCode;\n"
        "        }\n"
        "        this._encodeParameterId[parameterId] = parameterCode;\n"
        "        this._decodeParameterId[parameterCode] = parameterId;\n"
        "      });\n"
        "    }\n"
        "    _generateParameterCode() {\n"
        "      if (this._parameterCode > 65535)\n"
        "        throw Error(\"Too many parameters have been registered!\");\n"
        "      return this._parameterCode++;\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "    if (!ModuleScope.WamEventRingBuffer)\n"
        "      ModuleScope.WamEventRingBuffer = WamEventRingBuffer2;\n"
        "  }\n"
        "  return WamEventRingBuffer2;\n"
        "};\n"
        "var WamEventRingBuffer_default = getWamEventRingBuffer;\n"
        "\n"
        "// src/addFunctionModule.js\n"
        "var addFunctionModule = (audioWorklet, processorFunction, ...injection) => {\n"
        "  const text = `(${processorFunction.toString()})(${injection.map((s) => JSON.stringify(s)).join(\", \")});`;\n"
        "  const url = URL.createObjectURL(new Blob([text], { type: \"text/javascript\" }));\n"
        "  return audioWorklet.addModule(url);\n"
        "};\n"
        "var addFunctionModule_default = addFunctionModule;\n"
        "\n"
        "// src/WamParameter.js\n"
        "var getWamParameter = (moduleId) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  class WamParameter {\n"
        "    constructor(info) {\n"
        "      this.info = info;\n"
        "      this._value = info.defaultValue;\n"
        "    }\n"
        "    set value(value) {\n"
        "      this._value = value;\n"
        "    }\n"
        "    get value() {\n"
        "      return this._value;\n"
        "    }\n"
        "    set normalizedValue(valueNorm) {\n"
        "      this.value = this.info.denormalize(valueNorm);\n"
        "    }\n"
        "    get normalizedValue() {\n"
        "      return this.info.normalize(this.value);\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "    if (!ModuleScope.WamParameter)\n"
        "      ModuleScope.WamParameter = WamParameter;\n"
        "  }\n"
        "  return WamParameter;\n"
        "};\n"
        "var WamParameter_default = getWamParameter;\n"
        "\n"
        "// src/WamParameterInfo.js\n"
        "var getWamParameterInfo = (moduleId) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  const normExp = (x, e) => e === 0 ? x : x ** 1.5 ** -e;\n"
        "  const denormExp = (x, e) => e === 0 ? x : x ** 1.5 ** e;\n"
        "  const normalize = (x, min, max, e = 0) => min === 0 && max === 1 ? normExp(x, e) : normExp((x - min) / (max - min) || 0, e);\n"
        "  const denormalize = (x, min, max, e = 0) => min === 0 && max === 1 ? denormExp(x, e) : denormExp(x, e) * (max - min) + min;\n"
        "  const inRange = (x, min, max) => x >= min && x <= max;\n"
        "  class WamParameterInfo {\n"
        "    constructor(id, config = {}) {\n"
        "      let {\n"
        "        type,\n"
        "        label,\n"
        "        defaultValue,\n"
        "        minValue,\n"
        "        maxValue,\n"
        "        discreteStep,\n"
        "        exponent,\n"
        "        choices,\n"
        "        units\n"
        "      } = config;\n"
        "      if (type === void 0)\n"
        "        type = \"float\";\n"
        "      if (label === void 0)\n"
        "        label = \"\";\n"
        "      if (defaultValue === void 0)\n"
        "        defaultValue = 0;\n"
        "      if (choices === void 0)\n"
        "        choices = [];\n"
        "      if (type === \"boolean\" || type === \"choice\") {\n"
        "        discreteStep = 1;\n"
        "        minValue = 0;\n"
        "        if (choices.length)\n"
        "          maxValue = choices.length - 1;\n"
        "        else\n"
        "          maxValue = 1;\n"
        "      } else {\n"
        "        if (minValue === void 0)\n"
        "          minValue = 0;\n"
        "        if (maxValue === void 0)\n"
        "          maxValue = 1;\n"
        "        if (discreteStep === void 0)\n"
        "          discreteStep = 0;\n"
        "        if (exponent === void 0)\n"
        "          exponent = 0;\n"
        "        if (units === void 0)\n"
        "          units = \"\";\n"
        "      }\n"
        "      const errBase = `Param config error | ${id}: `;\n"
        "      if (minValue >= maxValue)\n"
        "        throw Error(errBase.concat(\"minValue must be less than maxValue\"));\n"
        "      if (!inRange(defaultValue, minValue, maxValue))\n"
        "        throw Error(errBase.concat(\"defaultValue out of range\"));\n"
        "      if (discreteStep % 1 || discreteStep < 0) {\n"
        "        throw Error(errBase.concat(\"discreteStep must be a non-negative integer\"));\n"
        "      } else if (discreteStep > 0 && (minValue % 1 || maxValue % 1 || defaultValue % 1)) {\n"
        "        throw Error(errBase.concat(\"non-zero discreteStep requires integer minValue, maxValue, and defaultValue\"));\n"
        "      }\n"
        "      if (type === \"choice\" && !choices.length) {\n"
        "        throw Error(errBase.concat(\"choice type parameter requires list of strings in choices\"));\n"
        "      }\n"
        "      this.id = id;\n"
        "      this.label = label;\n"
        "      this.type = type;\n"
        "      this.defaultValue = defaultValue;\n"
        "      this.minValue = minValue;\n"
        "      this.maxValue = maxValue;\n"
        "      this.discreteStep = discreteStep;\n"
        "      this.exponent = exponent;\n"
        "      this.choices = choices;\n"
        "      this.units = units;\n"
        "    }\n"
        "    normalize(value) {\n"
        "      return normalize(value, this.minValue, this.maxValue, this.exponent);\n"
        "    }\n"
        "    denormalize(valueNorm) {\n"
        "      return denormalize(valueNorm, this.minValue, this.maxValue, this.exponent);\n"
        "    }\n"
        "    valueString(value) {\n"
        "      if (this.choices)\n"
        "        return this.choices[value];\n"
        "      if (this.units !== \"\")\n"
        "        return `${value} ${this.units}`;\n"
        "      return `${value}`;\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "    if (!ModuleScope.WamParameterInfo)\n"
        "      ModuleScope.WamParameterInfo = WamParameterInfo;\n"
        "  }\n"
        "  return WamParameterInfo;\n"
        "};\n"
        "var WamParameterInfo_default = getWamParameterInfo;\n"
        "\n"
        "// src/WamParameterInterpolator.js\n"
        "var getWamParameterInterpolator = (moduleId) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  const samplesPerQuantum = 128;\n"
        "  const nullTableKey = \"0_0\";\n"
        "  class WamParameterInterpolator {\n"
        "    static _tables;\n"
        "    static _tableReferences;\n"
        "    constructor(info, samplesPerInterpolation, skew = 0) {\n"
        "      if (!WamParameterInterpolator._tables) {\n"
        "        WamParameterInterpolator._tables = { nullTableKey: new Float32Array(0) };\n"
        "        WamParameterInterpolator._tableReferences = { nullTableKey: [] };\n"
        "      }\n"
        "      this.info = info;\n"
        "      this.values = new Float32Array(samplesPerQuantum);\n"
        "      this._tableKey = nullTableKey;\n"
        "      this._table = WamParameterInterpolator._tables[this._tableKey];\n"
        "      this._skew = 2;\n"
        "      const { discreteStep } = info;\n"
        "      this._discrete = !!discreteStep;\n"
        "      this._N = this._discrete ? 0 : samplesPerInterpolation;\n"
        "      this._n = 0;\n"
        "      this._startValue = info.defaultValue;\n"
        "      this._endValue = info.defaultValue;\n"
        "      this._currentValue = info.defaultValue;\n"
        "      this._deltaValue = 0;\n"
        "      this._inverted = false;\n"
        "      this._changed = true;\n"
        "      this._filled = 0;\n"
        "      if (!this._discrete)\n"
        "        this.setSkew(skew);\n"
        "      else\n"
        "        this._skew = 0;\n"
        "      this.setStartValue(this._startValue);\n"
        "    }\n"
        "    _removeTableReference(oldKey) {\n"
        "      if (oldKey === nullTableKey)\n"
        "        return;\n"
        "      const { id } = this.info;\n"
        "      const references = WamParameterInterpolator._tableReferences[oldKey];\n"
        "      if (references) {\n"
        "        const index = references.indexOf(id);\n"
        "        if (index !== -1)\n"
        "          references.splice(index, 1);\n"
        "        if (references.length === 0) {\n"
        "          delete WamParameterInterpolator._tables[oldKey];\n"
        "          delete WamParameterInterpolator._tableReferences[oldKey];\n"
        "        }\n"
        "      }\n"
        "    }\n"
        "    setSkew(skew) {\n"
        "      if (this._skew === skew || this._discrete)\n"
        "        return;\n"
        "      if (skew < -1 || skew > 1)\n"
        "        throw Error(\"skew must be in range [-1.0, 1.0]\");\n"
        "      const newKey = [this._N, skew].join(\"_\");\n"
        "      const oldKey = this._tableKey;\n"
        "      const { id } = this.info;\n"
        "      if (newKey === oldKey)\n"
        "        return;\n"
        "      if (WamParameterInterpolator._tables[newKey]) {\n"
        "        const references = WamParameterInterpolator._tableReferences[newKey];\n"
        "        if (references)\n"
        "          references.push(id);\n"
        "        else\n"
        "          WamParameterInterpolator._tableReferences[newKey] = [id];\n"
        "      } else {\n"
        "        let e = Math.abs(skew);\n"
        "        e = Math.pow(3 - e, e * (e + 2));\n"
        "        const linear = e === 1;\n"
        "        const N = this._N;\n"
        "        const table = new Float32Array(N + 1);\n"
        "        if (linear)\n"
        "          for (let n = 0; n <= N; ++n)\n"
        "            table[n] = n / N;\n"
        "        else\n"
        "          for (let n = 0; n <= N; ++n)\n"
        "            table[n] = (n / N) ** e;\n"
        "        WamParameterInterpolator._tables[newKey] = table;\n"
        "        WamParameterInterpolator._tableReferences[newKey] = [id];\n"
        "      }\n"
        "      this._removeTableReference(oldKey);\n"
        "      this._skew = skew;\n"
        "      this._tableKey = newKey;\n"
        "      this._table = WamParameterInterpolator._tables[this._tableKey];\n"
        "    }\n"
        "    setStartValue(value, fill = true) {\n"
        "      this._n = this._N;\n"
        "      this._startValue = value;\n"
        "      this._endValue = value;\n"
        "      this._currentValue = value;\n"
        "      this._deltaValue = 0;\n"
        "      this._inverted = false;\n"
        "      if (fill) {\n"
        "        this.values.fill(value);\n"
        "        this._changed = true;\n"
        "        this._filled = this.values.length;\n"
        "      } else {\n"
        "        this._changed = false;\n"
        "        this._filled = 0;\n"
        "      }\n"
        "    }\n"
        "    setEndValue(value) {\n"
        "      if (value === this._endValue)\n"
        "        return;\n"
        "      this._n = 0;\n"
        "      this._startValue = this._currentValue;\n"
        "      this._endValue = value;\n"
        "      this._deltaValue = this._endValue - this._startValue;\n"
        "      this._inverted = this._deltaValue > 0 && this._skew >= 0 || this._deltaValue <= 0 && this._skew < 0;\n"
        "      this._changed = false;\n"
        "      this._filled = 0;\n"
        "    }\n"
        "    process(startSample, endSample) {\n"
        "      if (this.done)\n"
        "        return;\n"
        "      const length = endSample - startSample;\n"
        "      let fill = 0;\n"
        "      const change = this._N - this._n;\n"
        "      if (this._discrete || !change)\n"
        "        fill = length;\n"
        "      else {\n"
        "        if (change < length) {\n"
        "          fill = Math.min(length - change, samplesPerQuantum);\n"
        "          endSample -= fill;\n"
        "        }\n"
        "        if (endSample > startSample) {\n"
        "          if (this._inverted) {\n"
        "            for (let i = startSample; i < endSample; ++i) {\n"
        "              const tableValue = 1 - this._table[this._N - ++this._n];\n"
        "              this.values[i] = this._startValue + tableValue * this._deltaValue;\n"
        "            }\n"
        "          } else {\n"
        "            for (let i = startSample; i < endSample; ++i) {\n"
        "              const tableValue = this._table[++this._n];\n"
        "              this.values[i] = this._startValue + tableValue * this._deltaValue;\n"
        "            }\n"
        "          }\n"
        "        }\n"
        "        if (fill > 0) {\n"
        "          startSample = endSample;\n"
        "          endSample += fill;\n"
        "        }\n"
        "      }\n"
        "      if (fill > 0) {\n"
        "        this.values.fill(this._endValue, startSample, endSample);\n"
        "        this._filled += fill;\n"
        "      }\n"
        "      this._currentValue = this.values[endSample - 1];\n"
        "      if (this._n === this._N) {\n"
        "        if (!this._changed)\n"
        "          this._changed = true;\n"
        "        else if (this._filled >= this.values.length) {\n"
        "          this.setStartValue(this._endValue, false);\n"
        "          this._changed = true;\n"
        "          this._filled = this.values.length;\n"
        "        }\n"
        "      }\n"
        "    }\n"
        "    get done() {\n"
        "      return this._changed && this._filled === this.values.length;\n"
        "    }\n"
        "    is(value) {\n"
        "      return this._endValue === value && this.done;\n"
        "    }\n"
        "    destroy() {\n"
        "      this._removeTableReference(this._tableKey);\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "    if (!ModuleScope.WamParameterInterpolator)\n"
        "      ModuleScope.WamParameterInterpolator = WamParameterInterpolator;\n"
        "  }\n"
        "  return WamParameterInterpolator;\n"
        "};\n"
        "var WamParameterInterpolator_default = getWamParameterInterpolator;\n"
        "\n"
        "// src/WamProcessor.js\n"
        "var getWamProcessor = (moduleId) => {\n"
        "  const audioWorkletGlobalScope = globalThis;\n"
        "  const {\n"
        "    AudioWorkletProcessor,\n"
        "    webAudioModules\n"
        "  } = audioWorkletGlobalScope;\n"
        "  const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n"
        "  const {\n"
        "    RingBuffer: RingBuffer2,\n"
        "    WamEventRingBuffer: WamEventRingBuffer2,\n"
        "    WamParameter,\n"
        "    WamParameterInterpolator\n"
        "  } = ModuleScope;\n"
        "  class WamProcessor extends AudioWorkletProcessor {\n"
        "    constructor(options) {\n"
        "      super();\n"
        "      const {\n"
        "        groupId,\n"
        "        moduleId: moduleId2,\n"
        "        instanceId,\n"
        "        useSab\n"
        "      } = options.processorOptions;\n"
        "      if (!moduleId2)\n"
        "        throw Error(\"must provide moduleId argument in processorOptions!\");\n"
        "      if (!instanceId)\n"
        "        throw Error(\"must provide instanceId argument in processorOptions!\");\n"
        "      this.groupId = groupId;\n"
        "      this.moduleId = moduleId2;\n"
        "      this.instanceId = instanceId;\n"
        "      this._samplesPerQuantum = 128;\n"
        "      this._compensationDelay = 0;\n"
        "      this._parameterInfo = {};\n"
        "      this._parameterState = {};\n"
        "      this._parameterInterpolators = {};\n"
        "      this._eventQueue = [];\n"
        "      this._pendingResponses = {};\n"
        "      this._useSab = !!useSab && !!globalThis.SharedArrayBuffer;\n"
        "      this._eventSabReady = false;\n"
        "      this._audioToMainEventSab = null;\n"
        "      this._mainToAudioEventSab = null;\n"
        "      this._eventWriter = null;\n"
        "      this._eventReader = null;\n"
        "      this._initialized = false;\n"
        "      this._destroyed = false;\n"
        "      webAudioModules.addWam(this);\n"
        "      this.port.onmessage = this._onMessage.bind(this);\n"
        "      if (this._useSab)\n"
        "        this._configureSab();\n"
        "    }\n"
        "    getCompensationDelay() {\n"
        "      return this._compensationDelay;\n"
        "    }\n"
        "    scheduleEvents(...events) {\n"
        "      let i = 0;\n"
        "      while (i < events.length) {\n"
        "        this._eventQueue.push({ id: 0, event: events[i] });\n"
        "        i++;\n"
        "      }\n"
        "    }\n"
        "    emitEvents(...events) {\n"
        "      webAudioModules.emitEvents(this, ...events);\n"
        "    }\n"
        "    clearEvents() {\n"
        "      this._eventQueue = [];\n"
        "    }\n"
        "    process(inputs, outputs, parameters) {\n"
        "      if (!this._initialized)\n"
        "        return true;\n"
        "      if (this._destroyed)\n"
        "        return false;\n"
        "      if (this._eventSabReady)\n"
        "        this.scheduleEvents(...this._eventReader.read());\n"
        "      const processingSlices = this._getProcessingSlices();\n"
        "      let i = 0;\n"
        "      while (i < processingSlices.length) {\n"
        "        const { range, events } = processingSlices[i];\n"
        "        const [startSample, endSample] = range;\n"
        "        let j = 0;\n"
        "        while (j < events.length) {\n"
        "          this._processEvent(events[j]);\n"
        "          j++;\n"
        "        }\n"
        "        this._interpolateParameterValues(startSample, endSample);\n"
        "        this._process(startSample, endSample, inputs, outputs, parameters);\n"
        "        i++;\n"
        "      }\n"
        "      return true;\n"
        "    }\n"
        "    destroy() {\n"
        "      this._destroyed = true;\n"
        "      this.port.close();\n"
        "      webAudioModules.removeWam(this);\n"
        "    }\n"
        "    _generateWamParameterInfo() {\n"
        "      return {};\n"
        "    }\n"
        "    _initialize() {\n"
        "      this._parameterState = {};\n"
        "      this._parameterInterpolators = {};\n"
        "      this._parameterInfo = this._generateWamParameterInfo();\n"
        "      Object.keys(this._parameterInfo).forEach((parameterId) => {\n"
        "        const info = this._parameterInfo[parameterId];\n"
        "        this._parameterState[parameterId] = new WamParameter(this._parameterInfo[parameterId]);\n"
        "        this._parameterInterpolators[parameterId] = new WamParameterInterpolator(info, 256);\n"
        "      });\n"
        "    }\n"
        "    _configureSab() {\n"
        "      const eventCapacity = 2 ** 10;\n"
        "      const parameterIds = Object.keys(this._parameterInfo);\n"
        "      if (this._eventSabReady) {\n"
        "        this._eventWriter.setParameterIds(parameterIds);\n"
        "        this._eventReader.setParameterIds(parameterIds);\n"
        "      }\n"
        "      this.port.postMessage({ eventSab: { eventCapacity, parameterIds } });\n"
        "    }\n"
        "    async _onMessage(message) {\n"
        "      if (message.data.request) {\n"
        "        const {\n"
        "          id,\n"
        "          request,\n"
        "          content\n"
        "        } = message.data;\n"
        "        const response = { id, response: request };\n"
        "        const requestComponents = request.split(\"/\");\n"
        "        const verb = requestComponents[0];\n"
        "        const noun = requestComponents[1];\n"
        "        response.content = \"error\";\n"
        "        if (verb === \"get\") {\n"
        "          if (noun === \"parameterInfo\") {\n"
        "            let { parameterIds } = content;\n"
        "            if (!parameterIds.length)\n"
        "              parameterIds = Object.keys(this._parameterInfo);\n"
        "            const parameterInfo = {};\n"
        "            let i = 0;\n"
        "            while (i < parameterIds.length) {\n"
        "              const parameterId = parameterIds[i];\n"
        "              parameterInfo[parameterId] = this._parameterInfo[parameterId];\n"
        "              i++;\n"
        "            }\n"
        "            response.content = parameterInfo;\n"
        "          } else if (noun === \"parameterValues\") {\n"
        "            let { normalized, parameterIds } = content;\n"
        "            response.content = this._getParameterValues(normalized, parameterIds);\n"
        "          } else if (noun === \"state\") {\n"
        "            response.content = this._getState();\n"
        "          } else if (noun === \"compensationDelay\") {\n"
        "            response.content = this.getCompensationDelay();\n"
        "          }\n"
        "        } else if (verb === \"set\") {\n"
        "          if (noun === \"parameterValues\") {\n"
        "            const { parameterValues } = content;\n"
        "            this._setParameterValues(parameterValues, true);\n"
        "            delete response.content;\n"
        "          } else if (noun === \"state\") {\n"
        "            const { state } = content;\n"
        "            this._setState(state);\n"
        "            delete response.content;\n"
        "          }\n"
        "        } else if (verb === \"add\") {\n"
        "          if (noun === \"event\") {\n"
        "            const { event } = content;\n"
        "            this._eventQueue.push({ id, event });\n"
        "            return;\n"
        "          }\n"
        "        } else if (verb === \"remove\") {\n"
        "          if (noun === \"events\") {\n"
        "            const ids = this._eventQueue.map((queued) => queued.id);\n"
        "            this.clearEvents();\n"
        "            response.content = ids;\n"
        "          }\n"
        "        } else if (verb === \"connect\") {\n"
        "          if (noun === \"events\") {\n"
        "            const { wamInstanceId, output } = content;\n"
        "            this._connectEvents(wamInstanceId, output);\n"
        "            delete response.content;\n"
        "          }\n"
        "        } else if (verb === \"disconnect\") {\n"
        "          if (noun === \"events\") {\n"
        "            const { wamInstanceId, output } = content;\n"
        "            this._disconnectEvents(wamInstanceId, output);\n"
        "            delete response.content;\n"
        "          }\n"
        "        } else if (verb === \"initialize\") {\n"
        "          if (noun === \"processor\") {\n"
        "            this._initialize();\n"
        "            this._initialized = true;\n"
        "            delete response.content;\n"
        "          } else if (noun === \"eventSab\") {\n"
        "            const { mainToAudioEventSab, audioToMainEventSab } = content;\n"
        "            this._audioToMainEventSab = audioToMainEventSab;\n"
        "            this._mainToAudioEventSab = mainToAudioEventSab;\n"
        "            const parameterIds = Object.keys(this._parameterInfo);\n"
        "            this._eventWriter = new WamEventRingBuffer2(RingBuffer2, this._audioToMainEventSab, parameterIds);\n"
        "            this._eventReader = new WamEventRingBuffer2(RingBuffer2, this._mainToAudioEventSab, parameterIds);\n"
        "            this._eventSabReady = true;\n"
        "            delete response.content;\n"
        "          }\n"
        "        }\n"
        "        this.port.postMessage(response);\n"
        "      } else if (message.data.destroy) {\n"
        "        this.destroy();\n"
        "      }\n"
        "    }\n"
        "    _onTransport(transportData) {\n"
        "      console.error(\"_onTransport not implemented!\");\n"
        "    }\n"
        "    _onMidi(midiData) {\n"
        "      console.error(\"_onMidi not implemented!\");\n"
        "    }\n"
        "    _onSysex(sysexData) {\n"
        "      console.error(\"_onMidi not implemented!\");\n"
        "    }\n"
        "    _onMpe(mpeData) {\n"
        "      console.error(\"_onMpe not implemented!\");\n"
        "    }\n"
        "    _onOsc(oscData) {\n"
        "      console.error(\"_onOsc not implemented!\");\n"
        "    }\n"
        "    _setState(state) {\n"
        "      if (state.parameterValues)\n"
        "        this._setParameterValues(state.parameterValues, false);\n"
        "    }\n"
        "    _getState() {\n"
        "      return { parameterValues: this._getParameterValues(false) };\n"
        "    }\n"
        "    _getParameterValues(normalized, parameterIds) {\n"
        "      const parameterValues = {};\n"
        "      if (!parameterIds || !parameterIds.length)\n"
        "        parameterIds = Object.keys(this._parameterState);\n"
        "      let i = 0;\n"
        "      while (i < parameterIds.length) {\n"
        "        const id = parameterIds[i];\n"
        "        const parameter = this._parameterState[id];\n"
        "        parameterValues[id] = {\n"
        "          id,\n"
        "          value: normalized ? parameter.normalizedValue : parameter.value,\n"
        "          normalized\n"
        "        };\n"
        "        i++;\n"
        "      }\n"
        "      return parameterValues;\n"
        "    }\n"
        "    _setParameterValues(parameterUpdates, interpolate) {\n"
        "      const parameterIds = Object.keys(parameterUpdates);\n"
        "      let i = 0;\n"
        "      while (i < parameterIds.length) {\n"
        "        this._setParameterValue(parameterUpdates[parameterIds[i]], interpolate);\n"
        "        i++;\n"
        "      }\n"
        "    }\n"
        "    _setParameterValue(parameterUpdate, interpolate) {\n"
        "      const { id, value, normalized } = parameterUpdate;\n"
        "      const parameter = this._parameterState[id];\n"
        "      if (!parameter)\n"
        "        return;\n"
        "      if (!normalized)\n"
        "        parameter.value = value;\n"
        "      else\n"
        "        parameter.normalizedValue = value;\n"
        "      const interpolator = this._parameterInterpolators[id];\n"
        "      if (interpolate)\n"
        "        interpolator.setEndValue(parameter.value);\n"
        "      else\n"
        "        interpolator.setStartValue(parameter.value);\n"
        "    }\n"
        "    _interpolateParameterValues(startIndex, endIndex) {\n"
        "      const parameterIds = Object.keys(this._parameterInterpolators);\n"
        "      let i = 0;\n"
        "      while (i < parameterIds.length) {\n"
        "        this._parameterInterpolators[parameterIds[i]].process(startIndex, endIndex);\n"
        "        i++;\n"
        "      }\n"
        "    }\n"
        "    _connectEvents(wamInstanceId, output) {\n"
        "      webAudioModules.connectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n"
        "    }\n"
        "    _disconnectEvents(wamInstanceId, output) {\n"
        "      if (typeof wamInstanceId === \"undefined\") {\n"
        "        webAudioModules.disconnectEvents(this.groupId, this.instanceId);\n"
        "        return;\n"
        "      }\n"
        "      webAudioModules.disconnectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n"
        "    }\n"
        "    _getProcessingSlices() {\n"
        "      const response = \"add/event\";\n"
        "      const { currentTime, sampleRate } = audioWorkletGlobalScope;\n"
        "      const eventsBySampleIndex = {};\n"
        "      let i = 0;\n"
        "      while (i < this._eventQueue.length) {\n"
        "        const { id, event } = this._eventQueue[i];\n"
        "        const offsetSec = event.time - currentTime;\n"
        "        const sampleIndex = offsetSec > 0 ? Math.round(offsetSec * sampleRate) : 0;\n"
        "        if (sampleIndex < this._samplesPerQuantum) {\n"
        "          if (eventsBySampleIndex[sampleIndex])\n"
        "            eventsBySampleIndex[sampleIndex].push(event);\n"
        "          else\n"
        "            eventsBySampleIndex[sampleIndex] = [event];\n"
        "          if (id)\n"
        "            this.port.postMessage({ id, response });\n"
        "          else if (this._eventSabReady)\n"
        "            this._eventWriter.write(event);\n"
        "          else\n"
        "            this.port.postMessage({ event });\n"
        "          this._eventQueue.shift();\n"
        "          i = -1;\n"
        "        } else\n"
        "          break;\n"
        "        i++;\n"
        "      }\n"
        "      const processingSlices = [];\n"
        "      const keys = Object.keys(eventsBySampleIndex);\n"
        "      if (keys[0] !== \"0\") {\n"
        "        keys.unshift(\"0\");\n"
        "        eventsBySampleIndex[\"0\"] = [];\n"
        "      }\n"
        "      const lastIndex = keys.length - 1;\n"
        "      i = 0;\n"
        "      while (i < keys.length) {\n"
        "        const key = keys[i];\n"
        "        const startSample = parseInt(key);\n"
        "        const endSample = i < lastIndex ? parseInt(keys[i + 1]) : this._samplesPerQuantum;\n"
        "        processingSlices.push({ range: [startSample, endSample], events: eventsBySampleIndex[key] });\n"
        "        i++;\n"
        "      }\n"
        "      return processingSlices;\n"
        "    }\n"
        "    _processEvent(event) {\n"
        "      switch (event.type) {\n"
        "        case \"wam-automation\":\n"
        "          this._setParameterValue(event.data, true);\n"
        "          break;\n"
        "        case \"wam-transport\":\n"
        "          this._onTransport(event.data);\n"
        "          break;\n"
        "        case \"wam-midi\":\n"
        "          this._onMidi(event.data);\n"
        "          break;\n"
        "        case \"wam-sysex\":\n"
        "          this._onSysex(event.data);\n"
        "          break;\n"
        "        case \"wam-mpe\":\n"
        "          this._onMpe(event.data);\n"
        "          break;\n"
        "        case \"wam-osc\":\n"
        "          this._onOsc(event.data);\n"
        "          break;\n"
        "        default:\n"
        "          break;\n"
        "      }\n"
        "    }\n"
        "    _process(startSample, endSample, inputs, outputs, parameters) {\n"
        "      console.error(\"_process not implemented!\");\n"
        "    }\n"
        "  }\n"
        "  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n"
        "    if (!ModuleScope.WamProcessor)\n"
        "      ModuleScope.WamProcessor = WamProcessor;\n"
        "  }\n"
        "  return WamProcessor;\n"
        "};\n"
        "var WamProcessor_default = getWamProcessor;\n"
        "\n"
        "// src/WamNode.js\n"
        "var RingBuffer = RingBuffer_default();\n"
        "var WamEventRingBuffer = WamEventRingBuffer_default();\n"
        "var WamNode = class extends AudioWorkletNode {\n"
        "  static async addModules(audioContext, moduleId) {\n"
        "    const { audioWorklet } = audioContext;\n"
        "    await addFunctionModule_default(audioWorklet, RingBuffer_default, moduleId);\n"
        "    await addFunctionModule_default(audioWorklet, WamEventRingBuffer_default, moduleId);\n"
        "    await addFunctionModule_default(audioWorklet, WamArrayRingBuffer_default, moduleId);\n"
        "    await addFunctionModule_default(audioWorklet, WamParameter_default, moduleId);\n"
        "    await addFunctionModule_default(audioWorklet, WamParameterInfo_default, moduleId);\n"
        "    await addFunctionModule_default(audioWorklet, WamParameterInterpolator_default, moduleId);\n"
        "    await addFunctionModule_default(audioWorklet, WamProcessor_default, moduleId);\n"
        "  }\n"
        "  constructor(module, options) {\n"
        "    const { audioContext, groupId, moduleId, instanceId } = module;\n"
        "    options.processorOptions = {\n"
        "      groupId,\n"
        "      moduleId,\n"
        "      instanceId,\n"
        "      ...options.processorOptions\n"
        "    };\n"
        "    super(audioContext, moduleId, options);\n"
        "    this.module = module;\n"
        "    this._supportedEventTypes = /* @__PURE__ */ new Set([\"wam-automation\", \"wam-transport\", \"wam-midi\", \"wam-sysex\", \"wam-mpe\", \"wam-osc\"]);\n"
        "    this._messageId = 1;\n"
        "    this._pendingResponses = {};\n"
        "    this._pendingEvents = {};\n"
        "    this._useSab = false;\n"
        "    this._eventSabReady = false;\n"
        "    this._destroyed = false;\n"
        "    this.port.onmessage = this._onMessage.bind(this);\n"
        "  }\n"
        "  get groupId() {\n"
        "    return this.module.groupId;\n"
        "  }\n"
        "  get moduleId() {\n"
        "    return this.module.moduleId;\n"
        "  }\n"
        "  get instanceId() {\n"
        "    return this.module.instanceId;\n"
        "  }\n"
        "  async getParameterInfo(...parameterIds) {\n"
        "    const request = \"get/parameterInfo\";\n"
        "    const id = this._generateMessageId();\n"
        "    return new Promise((resolve) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({\n"
        "        id,\n"
        "        request,\n"
        "        content: { parameterIds }\n"
        "      });\n"
        "    });\n"
        "  }\n"
        "  async getParameterValues(normalized, ...parameterIds) {\n"
        "    const request = \"get/parameterValues\";\n"
        "    const id = this._generateMessageId();\n"
        "    return new Promise((resolve) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({\n"
        "        id,\n"
        "        request,\n"
        "        content: { normalized, parameterIds }\n"
        "      });\n"
        "    });\n"
        "  }\n"
        "  async setParameterValues(parameterValues) {\n"
        "    const request = \"set/parameterValues\";\n"
        "    const id = this._generateMessageId();\n"
        "    return new Promise((resolve) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({\n"
        "        id,\n"
        "        request,\n"
        "        content: { parameterValues }\n"
        "      });\n"
        "    });\n"
        "  }\n"
        "  async getState() {\n"
        "    const request = \"get/state\";\n"
        "    const id = this._generateMessageId();\n"
        "    return new Promise((resolve) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({ id, request });\n"
        "    });\n"
        "  }\n"
        "  async setState(state) {\n"
        "    const request = \"set/state\";\n"
        "    const id = this._generateMessageId();\n"
        "    return new Promise((resolve) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({\n"
        "        id,\n"
        "        request,\n"
        "        content: { state }\n"
        "      });\n"
        "    });\n"
        "  }\n"
        "  async getCompensationDelay() {\n"
        "    const request = \"get/compensationDelay\";\n"
        "    const id = this._generateMessageId();\n"
        "    return new Promise((resolve) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({ id, request });\n"
        "    });\n"
        "  }\n"
        "  addEventListener(type, callback, options) {\n"
        "    if (this._supportedEventTypes.has(type))\n"
        "      super.addEventListener(type, callback, options);\n"
        "  }\n"
        "  removeEventListener(type, callback, options) {\n"
        "    if (this._supportedEventTypes.has(type))\n"
        "      super.removeEventListener(type, callback, options);\n"
        "  }\n"
        "  scheduleEvents(...events) {\n"
        "    let i = 0;\n"
        "    const numEvents = events.length;\n"
        "    if (this._eventSabReady) {\n"
        "      i = this._eventWriter.write(...events);\n"
        "    }\n"
        "    while (i < numEvents) {\n"
        "      const event = events[i];\n"
        "      const request = \"add/event\";\n"
        "      const id = this._generateMessageId();\n"
        "      let processed = false;\n"
        "      new Promise((resolve, reject) => {\n"
        "        this._pendingResponses[id] = resolve;\n"
        "        this._pendingEvents[id] = () => {\n"
        "          if (!processed)\n"
        "            reject();\n"
        "        };\n"
        "        this.port.postMessage({\n"
        "          id,\n"
        "          request,\n"
        "          content: { event }\n"
        "        });\n"
        "      }).then((resolved) => {\n"
        "        processed = true;\n"
        "        delete this._pendingEvents[id];\n"
        "        this._onEvent(event);\n"
        "      }).catch((rejected) => {\n"
        "        delete this._pendingResponses[id];\n"
        "      });\n"
        "      i++;\n"
        "    }\n"
        "  }\n"
        "  async clearEvents() {\n"
        "    const request = \"remove/events\";\n"
        "    const id = this._generateMessageId();\n"
        "    const ids = Object.keys(this._pendingEvents);\n"
        "    if (ids.length) {\n"
        "      return new Promise((resolve) => {\n"
        "        this._pendingResponses[id] = resolve;\n"
        "        this.port.postMessage({ id, request });\n"
        "      }).then((clearedIds) => {\n"
        "        clearedIds.forEach((clearedId) => {\n"
        "          this._pendingEvents[clearedId]();\n"
        "          delete this._pendingEvents[clearedId];\n"
        "        });\n"
        "      });\n"
        "    }\n"
        "  }\n"
        "  connectEvents(toId, output) {\n"
        "    const request = \"connect/events\";\n"
        "    const id = this._generateMessageId();\n"
        "    new Promise((resolve, reject) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({\n"
        "        id,\n"
        "        request,\n"
        "        content: { wamInstanceId: toId, output }\n"
        "      });\n"
        "    });\n"
        "  }\n"
        "  disconnectEvents(toId, output) {\n"
        "    const request = \"disconnect/events\";\n"
        "    const id = this._generateMessageId();\n"
        "    new Promise((resolve, reject) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({\n"
        "        id,\n"
        "        request,\n"
        "        content: { wamInstanceId: toId, output }\n"
        "      });\n"
        "    });\n"
        "  }\n"
        "  destroy() {\n"
        "    if (this._audioToMainInterval)\n"
        "      clearInterval(this._audioToMainInterval);\n"
        "    this.port.postMessage({ destroy: true });\n"
        "    this.port.close();\n"
        "    this.disconnect();\n"
        "    this._destroyed = true;\n"
        "  }\n"
        "  _generateMessageId() {\n"
        "    return this._messageId++;\n"
        "  }\n"
        "  async _initialize() {\n"
        "    const request = \"initialize/processor\";\n"
        "    const id = this._generateMessageId();\n"
        "    return new Promise((resolve) => {\n"
        "      this._pendingResponses[id] = resolve;\n"
        "      this.port.postMessage({ id, request });\n"
        "    });\n"
        "  }\n"
        "  _onMessage(message) {\n"
        "    const { data } = message;\n"
        "    const { response, event, eventSab } = data;\n"
        "    if (response) {\n"
        "      const { id, content } = data;\n"
        "      const resolvePendingResponse = this._pendingResponses[id];\n"
        "      if (resolvePendingResponse) {\n"
        "        delete this._pendingResponses[id];\n"
        "        resolvePendingResponse(content);\n"
        "      }\n"
        "    } else if (eventSab) {\n"
        "      this._useSab = true;\n"
        "      const { eventCapacity, parameterIds } = eventSab;\n"
        "      if (this._eventSabReady) {\n"
        "        this._eventWriter.setParameterIds(parameterIds);\n"
        "        this._eventReader.setParameterIds(parameterIds);\n"
        "        return;\n"
        "      }\n"
        "      this._mainToAudioEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer, eventCapacity);\n"
        "      this._audioToMainEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer, eventCapacity);\n"
        "      this._eventWriter = new WamEventRingBuffer(RingBuffer, this._mainToAudioEventSab, parameterIds);\n"
        "      this._eventReader = new WamEventRingBuffer(RingBuffer, this._audioToMainEventSab, parameterIds);\n"
        "      const request = \"initialize/eventSab\";\n"
        "      const id = this._generateMessageId();\n"
        "      new Promise((resolve, reject) => {\n"
        "        this._pendingResponses[id] = resolve;\n"
        "        this.port.postMessage({\n"
        "          id,\n"
        "          request,\n"
        "          content: {\n"
        "            mainToAudioEventSab: this._mainToAudioEventSab,\n"
        "            audioToMainEventSab: this._audioToMainEventSab\n"
        "          }\n"
        "        });\n"
        "      }).then((resolved) => {\n"
        "        this._eventSabReady = true;\n"
        "        this._audioToMainInterval = setInterval(() => {\n"
        "          const events = this._eventReader.read();\n"
        "          events.forEach((e) => {\n"
        "            this._onEvent(e);\n"
        "          });\n"
        "        }, 100);\n"
        "      });\n"
        "    } else if (event)\n"
        "      this._onEvent(event);\n"
        "  }\n"
        "  _onEvent(event) {\n"
        "    const { type } = event;\n"
        "    this.dispatchEvent(new CustomEvent(type, {\n"
        "      bubbles: true,\n"
        "      detail: event\n"
        "    }));\n"
        "  }\n"
        "};\n"
        "\n"
        "// src/apiVersion.js\n"
        "var apiVersion_default = \"2.0.0-alpha.6\";\n"
        "\n"
        "// src/initializeWamHost.js\n"
        "var initializeWamHost = async (audioContext, hostGroupId = `wam-host-${performance.now().toString()}`, hostGroupKey = performance.now().toString()) => {\n"
        "  await addFunctionModule_default(audioContext.audioWorklet, WamEnv_default, apiVersion_default);\n"
        "  await addFunctionModule_default(audioContext.audioWorklet, WamGroup_default, hostGroupId, hostGroupKey);\n"
        "  return [hostGroupId, hostGroupKey];\n"
        "};\n"
        "var initializeWamHost_default = initializeWamHost;\n"
        "export {\n"
        "  WamNode,\n"
        "  WebAudioModule_default as WebAudioModule,\n"
        "  addFunctionModule_default as addFunctionModule,\n"
        "  apiVersion_default as apiVersion,\n"
        "  RingBuffer_default as getRingBuffer,\n"
        "  WamArrayRingBuffer_default as getWamArrayRingBuffer,\n"
        "  WamEventRingBuffer_default as getWamEventRingBuffer,\n"
        "  WamParameter_default as getWamParameter,\n"
        "  WamParameterInfo_default as getWamParameterInfo,\n"
        "  WamParameterInterpolator_default as getWamParameterInterpolator,\n"
        "  WamProcessor_default as getWamProcessor,\n"
        "  WamEnv_default as initializeWamEnv,\n"
        "  WamGroup_default as initializeWamGroup,\n"
        "  initializeWamHost_default as initializeWamHost\n"
        "};\n"
        "//# sourceMappingURL=index.js.map\n";


    static constexpr std::array files =
    {
        File { "sdk/parammgr.js", std::string_view (sdk_parammgr_js, 39773) },
        File { "sdk/index.js", std::string_view (sdk_index_js, 59572) }
    };

};

} // namespace cmaj
