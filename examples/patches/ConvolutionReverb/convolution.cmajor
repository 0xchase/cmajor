//
//     ,ad888ba,                              88
//    d8"'    "8b
//   d8            88,dba,,adba,   ,aPP8A.A8  88     The Cmajor Toolkit
//   Y8,           88    88    88  88     88  88
//    Y8a.   .a8P  88    88    88  88,   ,88  88     (C)2024 Cmajor Software Ltd
//     '"Y888Y"'   88    88    88  '"8bbP"Y8  88     https://cmajor.dev
//                                           ,88
//                                        888P"
//
//  The Cmajor project is subject to commercial or open-source licensing.
//  You may use it under the terms of the GPLv3 (see www.gnu.org/licenses), or
//  visit https://cmajor.dev to learn about our commercial licence options.
//
//  CMAJOR IS PROVIDED "AS IS" WITHOUT ANY WARRANTY, AND ALL WARRANTIES, WHETHER
//  EXPRESSED OR IMPLIED, INCLUDING MERCHANTABILITY AND FITNESS FOR PURPOSE, ARE
//  DISCLAIMED.

/// This namespace contains handy implementations of both time domain and frequency domain convolutions
namespace Convolution
{
    /// This is an implementation of a convolution reverb with zero latency.
    /// The impulse response is chopped into three parts, an initial part which is calculated using
    /// a time domain algorithm (and hence introduces no latency), a short FFT based algorithm, which
    /// fills in from the end of the time domain convolution, and a long FFT based algorithm that
    /// applies the majority of the convolution.
    ///
    /// By using three separate algorithms, and by dividing the impulse between them, we can trade off
    /// computational cost against latency, and the result is no introduced latency with good overall
    /// convolution performance. Modifying the FFT sizes will alter the performance characteristics
    graph ZeroLatencyProcessor (int shortBlockSize, int longBlockSize, int maxImpulseFrames)
    {
        input stream float in;
        output stream float out;
        input event float[] impulseData;

        event impulseData (float[] impulse)
        {
            convolution1.impulseData     <- impulse[:shortBlockSize/2];
            convolutionShort.impulseData <- impulse[shortBlockSize/2:longBlockSize/2];
            convolutionLong.impulseData  <- impulse[longBlockSize/2:];
        }

        node convolution1      = TimeDomainProcessor (shortBlockSize/2);
        node convolutionShort  = BlockProcessor (shortBlockSize, (longBlockSize - shortBlockSize));
        node convolutionLong   = BlockProcessor (longBlockSize, maxImpulseFrames);

        connection
        {
            in -> convolution1.in, convolutionShort.in, convolutionLong.in;

            convolution1.out -> out;
            convolutionShort.out -> out;
            convolutionLong.out -> out;
        }
    }

    /// This convolution algorithm uses a frequency domain implementation, with the blockSize altering
    /// the overall runtime and latency of the algorithm. Latecy is blockSize/2 frames. Larger block sizes
    /// will offer lower CPU use
    graph BlockProcessor (int blockSize, int maxImpulseFrames)
    {
        input stream float in;
        output stream float out;

        input conv.impulseData;

        node fft  = FFT (blockSize);
        node conv = Convolve (blockSize, maxImpulseFrames);
        node ifft = iFFT (blockSize);

        connection
        {
            in -> fft -> conv.in;
            conv.out -> ifft -> out;
        }
    }

    /// A simple time domain convolution algorithm. This will be costly to execute for longer impulses
    processor TimeDomainProcessor (int maxImpulseFrames)
    {
        input stream float in;
        output stream float out;
        input event float[] impulseData;

        event impulseData (float[] v)
        {
            impulse = 0.0f;

            for (wrap<maxImpulseFrames> i)
                if (i < v.size)
                    impulse[i] = v[i];
        }

        float<maxImpulseFrames> impulse;

        void main()
        {
            float<maxImpulseFrames> x;

            loop
            {
                x[1:] = x[0:maxImpulseFrames-1];
                x[0] = in;

                out <- sum (x * impulse);
                advance();
            }
        }
    }

    processor FFT (int blockSize)
    {
        input stream float in;
        output event complex[blockSize] out;

        complex[blockSize] buffer;

        void main()
        {
            loop
            {
                complex[blockSize] fft = buffer;

                std::frequency::complexFFT (fft);
                out <- fft;

                buffer[blockSize/2:] = buffer[:blockSize/2];

                for (wrap<blockSize/2> i)
                {
                    buffer[i] = in;
                    advance();
                }
            }

            advance();
        }
    }

    processor iFFT (int blockSize)
    {
        input event complex[blockSize] in;
        output stream float out;

        event in (complex[blockSize] data)
        {
            buffer = data;
            std::frequency::complexIFFT (buffer);
        }

        complex[blockSize] buffer;

        void main()
        {
            wrap<blockSize/2> i;

            loop
            {
                out <- buffer[i++].real;
                advance();
            }
        }
    }

    processor Convolve (int blockSize, int maxImpulseFrames)
    {
        input event complex[blockSize] in;
        output event complex[blockSize] out;
        input event float[] impulseData;

        event in (complex[blockSize] newBlock)
        {
            blockData[currentBlock] = newBlock;

            complex[blockSize] result;

            for (int block = 0; block < activeBlocks; block++)
            {
                let impulseBlock = wrap<numBlocks> (block);
                let dataBlock = wrap<numBlocks> (block + currentBlock);

                for (wrap<blockSize> i = 0; i <= blockSize/2; i++)
                    result[i] += blockData[dataBlock, i] * impulseFFT[impulseBlock, i];
            }

            for (wrap<blockSize/2> i = 1)
                result.at (blockSize - i) = complex32 (result[i].real, -result[i].imag);

            currentBlock--;

            out <- result;
        }

        event impulseData (float[] data)
        {
            activeBlocks = min (data.size / (blockSize / 2), numBlocks);

            for (int block = 0; block < activeBlocks; block++)
            {
                complex[blockSize] impulseSlice;

                int startFrame = block * (blockSize / 2);

                for (wrap<blockSize/2> i)
                    if ((startFrame + i) < data.size)
                        impulseSlice[i] = data.at (startFrame + i);

                impulseFFT.at (block) = impulseSlice;
                std::frequency::complexFFT (impulseFFT.at (block));
            }
        }

        int activeBlocks = 0;
        let numBlocks = 2 * maxImpulseFrames / blockSize;

        complex[numBlocks, blockSize] impulseFFT;
        complex[numBlocks, blockSize] blockData;

        wrap<numBlocks> currentBlock;
    }
}